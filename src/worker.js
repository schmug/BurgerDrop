// BurgerDrop Game - Built from modular source
// Auto-generated - do not edit directly
var htmlTemplate = "<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0, user-scalable=no\">\n    <title>Burger Drop! - Restaurant Game</title>\n    <link rel=\"icon\" href=\"data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>üçî</text></svg>\">\n    <link rel=\"preconnect\" href=\"https://fonts.googleapis.com\">\n    <link rel=\"preconnect\" href=\"https://fonts.gstatic.com\" crossorigin>\n    <link href=\"https://fonts.googleapis.com/css2?family=Fredoka+One:wght@400&family=Nunito:wght@400;600;700;800&display=swap\" rel=\"stylesheet\">\n    <style>\n        {{CSS_CONTENT}}\n    </style>\n</head>\n<body>\n    <div class=\"top-bar\">\n        <div class=\"logo\">\n            <span style=\"font-size: 36px;\">üçî</span>\n            <span>Burger Drop!</span>\n        </div>\n        <div class=\"score-display\" id=\"scoreDisplay\">Score: 0</div>\n        <button class=\"audio-toggle\" id=\"audioToggle\" aria-label=\"Toggle Audio\">üîä</button>\n    </div>\n\n    <div class=\"performance-overlay\" id=\"performanceOverlay\"></div>\n\n    <div class=\"game-container\">\n        <canvas id=\"gameCanvas\"></canvas>\n    </div>\n\n    <div class=\"game-over-overlay\" id=\"gameOverOverlay\">\n        <div class=\"game-over-content\">\n            <h1 class=\"game-over-title\">Game Over! üçî</h1>\n            <div class=\"final-score\">Final Score: <span id=\"finalScore\">0</span></div>\n            <div class=\"high-score\">High Score: <span id=\"highScore\">0</span></div>\n            <button class=\"play-again-btn\" id=\"playAgainBtn\">Play Again!</button>\n        </div>\n    </div>\n\n    <script>\n        // Wait for DOM to be ready before initializing the game\n        function initGame() {\n            const canvas = document.getElementById('gameCanvas');\n            if (canvas && typeof Game !== 'undefined') {\n                const game = new Game(canvas, {\n                    enablePerformanceMonitoring: false,\n                    showPerformanceUI: false\n                });\n                game.start();\n                \n                // Setup UI event handlers\n                const audioToggle = document.getElementById('audioToggle');\n                const playAgainBtn = document.getElementById('playAgainBtn');\n                \n                if (audioToggle) {\n                    audioToggle.addEventListener('click', () => {\n                        game.audioSystem.setEnabled(!game.audioSystem.isEnabled());\n                        audioToggle.textContent = game.audioSystem.isEnabled() ? 'üîä' : 'üîá';\n                    });\n                }\n                \n                if (playAgainBtn) {\n                    playAgainBtn.addEventListener('click', () => {\n                        document.getElementById('gameOverOverlay').style.display = 'none';\n                        game.start();\n                    });\n                }\n                \n                // Make game available globally for debugging\n                window.game = game;\n            }\n        }\n        \n        if (document.readyState === 'loading') {\n            document.addEventListener('DOMContentLoaded', initGame);\n        } else {\n            initGame();\n        }\n    </script>\n</body>\n</html>";

var cssContent = "/* BurgerDrop Game Styles */\n\n* {\n    margin: 0;\n    padding: 0;\n    box-sizing: border-box;\n    user-select: none;\n    -webkit-user-select: none;\n    -webkit-touch-callout: none;\n}\n\nbody {\n    font-family: 'Nunito', 'Arial', sans-serif;\n    background: \n        radial-gradient(circle at 20% 80%, rgba(255, 215, 0, 0.3) 0%, transparent 50%),\n        radial-gradient(circle at 80% 20%, rgba(255, 165, 0, 0.2) 0%, transparent 50%),\n        conic-gradient(from 45deg at 50% 50%, #87CEEB, #98D8C8, #87CEEB, #98D8C8);\n    overflow: hidden;\n    position: fixed;\n    width: 100%;\n    height: 100%;\n    animation: subtleShift 20s ease-in-out infinite;\n}\n\n#gameCanvas {\n    background: \n        radial-gradient(ellipse at top, rgba(255, 255, 255, 0.2) 0%, transparent 70%),\n        linear-gradient(135deg, #FFE4B5 0%, #FFDEAD 50%, #DEB887 100%);\n    display: block;\n    margin: 0 auto;\n    border: 3px solid #8B4513;\n    box-shadow: \n        0 0 20px rgba(139, 69, 19, 0.5),\n        inset 0 0 20px rgba(255, 255, 255, 0.1);\n    border-radius: 20px;\n    transition: transform 0.3s ease;\n}\n\n.game-container {\n    display: flex;\n    justify-content: center;\n    align-items: center;\n    min-height: 100vh;\n    padding: 20px;\n}\n\n.top-bar {\n    position: absolute;\n    top: 0;\n    left: 0;\n    right: 0;\n    background: rgba(255, 255, 255, 0.95);\n    padding: 15px 20px;\n    display: flex;\n    justify-content: space-between;\n    align-items: center;\n    box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);\n    z-index: 1000;\n    backdrop-filter: blur(10px);\n    border-bottom: 3px solid #8B4513;\n}\n\n.logo {\n    font-family: 'Fredoka One', cursive;\n    font-size: 28px;\n    color: #D2691E;\n    text-shadow: 2px 2px 4px rgba(139, 69, 19, 0.3);\n    display: flex;\n    align-items: center;\n    gap: 10px;\n}\n\n.score-display {\n    font-family: 'Fredoka One', cursive;\n    font-size: 24px;\n    color: #FF6347;\n    text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.2);\n}\n\n.audio-toggle {\n    background: #FFD700;\n    border: 3px solid #FFA500;\n    border-radius: 50%;\n    width: 50px;\n    height: 50px;\n    font-size: 24px;\n    cursor: pointer;\n    transition: all 0.3s ease;\n    box-shadow: 0 2px 10px rgba(0, 0, 0, 0.2);\n}\n\n.audio-toggle:hover {\n    transform: scale(1.1);\n    background: #FFA500;\n}\n\n.audio-toggle:active {\n    transform: scale(0.95);\n}\n\n.game-over-overlay {\n    position: fixed;\n    top: 0;\n    left: 0;\n    right: 0;\n    bottom: 0;\n    background: rgba(0, 0, 0, 0.85);\n    display: none;\n    justify-content: center;\n    align-items: center;\n    z-index: 2000;\n    backdrop-filter: blur(5px);\n}\n\n.game-over-content {\n    background: linear-gradient(135deg, #FFEAA7 0%, #FEF9E7 100%);\n    padding: 40px;\n    border-radius: 25px;\n    text-align: center;\n    box-shadow: \n        0 10px 40px rgba(0, 0, 0, 0.3),\n        inset 0 0 30px rgba(255, 255, 255, 0.5);\n    border: 5px solid #D2691E;\n    max-width: 90%;\n    animation: popIn 0.5s ease-out;\n}\n\n@keyframes popIn {\n    from {\n        transform: scale(0.8);\n        opacity: 0;\n    }\n    to {\n        transform: scale(1);\n        opacity: 1;\n    }\n}\n\n.game-over-title {\n    font-family: 'Fredoka One', cursive;\n    font-size: 48px;\n    color: #D2691E;\n    margin-bottom: 20px;\n    text-shadow: 3px 3px 6px rgba(0, 0, 0, 0.2);\n}\n\n.final-score {\n    font-size: 36px;\n    color: #FF6347;\n    margin: 20px 0;\n    font-weight: 800;\n}\n\n.high-score {\n    font-size: 24px;\n    color: #FFA500;\n    margin: 10px 0;\n    font-weight: 700;\n}\n\n.play-again-btn {\n    background: linear-gradient(135deg, #FF6347 0%, #FF4500 100%);\n    color: white;\n    border: none;\n    padding: 15px 40px;\n    font-size: 24px;\n    font-family: 'Fredoka One', cursive;\n    border-radius: 50px;\n    cursor: pointer;\n    margin-top: 20px;\n    box-shadow: \n        0 4px 15px rgba(255, 99, 71, 0.4),\n        inset 0 -3px 0 rgba(139, 0, 0, 0.3);\n    transition: all 0.3s ease;\n    text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3);\n}\n\n.play-again-btn:hover {\n    transform: translateY(-2px);\n    box-shadow: \n        0 6px 20px rgba(255, 99, 71, 0.5),\n        inset 0 -3px 0 rgba(139, 0, 0, 0.3);\n}\n\n.play-again-btn:active {\n    transform: translateY(0);\n    box-shadow: \n        0 2px 10px rgba(255, 99, 71, 0.4),\n        inset 0 -1px 0 rgba(139, 0, 0, 0.3);\n}\n\n@keyframes subtleShift {\n    0%, 100% {\n        background-position: 0% 50%;\n    }\n    50% {\n        background-position: 100% 50%;\n    }\n}\n\n@media (max-width: 768px) {\n    .game-container {\n        padding: 10px;\n        padding-top: 80px;\n    }\n    \n    .logo {\n        font-size: 20px;\n    }\n    \n    .score-display {\n        font-size: 18px;\n    }\n    \n    .audio-toggle {\n        width: 40px;\n        height: 40px;\n        font-size: 20px;\n    }\n    \n    .game-over-title {\n        font-size: 36px;\n    }\n    \n    .final-score {\n        font-size: 28px;\n    }\n    \n    .play-again-btn {\n        font-size: 20px;\n        padding: 12px 30px;\n    }\n}\n\n/* Performance overlay styles */\n.performance-overlay {\n    position: fixed;\n    top: 100px;\n    right: 20px;\n    background: rgba(0, 0, 0, 0.8);\n    color: #0f0;\n    font-family: monospace;\n    font-size: 12px;\n    padding: 10px;\n    border-radius: 5px;\n    display: none;\n    z-index: 3000;\n    min-width: 200px;\n}\n\n.performance-overlay.visible {\n    display: block;\n}\n\n.performance-overlay div {\n    margin: 5px 0;\n}\n\n.performance-overlay .label {\n    display: inline-block;\n    width: 80px;\n    color: #888;\n}\n\n.performance-overlay .value {\n    color: #0f0;\n}\n\n.performance-overlay .warning {\n    color: #ff0;\n}\n\n.performance-overlay .critical {\n    color: #f00;\n}";

var gameBundle = "var Game = (function () {\n    'use strict';\n\n    /**\n     * Game State Management\n     * \n     * Centralized state management system replacing global variables.\n     * Provides event-driven architecture with validation and debugging capabilities.\n     */\n\n    class GameState {\n        constructor() {\n            // Core game state\n            this.core = {\n                running: false,\n                score: 0,\n                lives: 3,\n                combo: 1,\n                level: 1,\n                frameCount: 0,\n                lastTime: 0,\n                highScore: this.loadHighScore()\n            };\n\n            // Entity collections\n            this.entities = {\n                ingredients: [],\n                orders: [],\n                powerUps: [],\n                particles: []\n            };\n\n            // Power-up state\n            this.powerUps = {\n                speedBoost: { active: false, timeLeft: 0, multiplier: 0.5 },\n                timeFreeze: { active: false, timeLeft: 0 },\n                scoreMultiplier: { active: false, timeLeft: 0, multiplier: 2 }\n            };\n\n            // UI state\n            this.ui = {\n                colorTheme: { hue: 200, saturation: 50, lightness: 45 },\n                screenEffects: {\n                    shake: { intensity: 0, duration: 0, x: 0, y: 0 },\n                    flash: { intensity: 0, color: '#ffffff' }\n                }\n            };\n\n            // Audio state\n            this.audio = {\n                enabled: true,\n                settings: { master: 0.7, effects: 0.8, music: 0.6 }\n            };\n\n            // Game timing\n            this.timing = {\n                ingredientSpeed: 4,\n                spawnRate: 40,\n                lastPowerUpSpawn: 0,\n                lastOrderSpawn: 0\n            };\n\n            // Event listeners for state changes\n            this.listeners = new Map();\n\n            // Development mode features\n            this.debug = {\n                enabled: false,\n                history: [],\n                validation: true\n            };\n        }\n\n        /**\n         * Core game state mutations\n         */\n        updateScore(points) {\n            const oldScore = this.core.score;\n            this.core.score += Math.floor(points);\n            \n            // Update high score if needed\n            if (this.core.score > this.core.highScore) {\n                this.core.highScore = this.core.score;\n                this.saveHighScore();\n                this.emit('newHighScore', this.core.highScore);\n            }\n            \n            this.emit('scoreChanged', { old: oldScore, new: this.core.score });\n        }\n\n        updateCombo(value) {\n            const oldCombo = this.core.combo;\n            this.core.combo = Math.max(1, Math.min(value, 10)); // Cap at 10\n            this.emit('comboChanged', { old: oldCombo, new: this.core.combo });\n        }\n\n        incrementCombo() {\n            this.updateCombo(this.core.combo + 1);\n        }\n\n        resetCombo() {\n            this.updateCombo(1);\n        }\n\n        loseLife() {\n            const oldLives = this.core.lives;\n            this.core.lives = Math.max(0, this.core.lives - 1);\n            this.emit('livesChanged', { old: oldLives, new: this.core.lives });\n            \n            if (this.core.lives === 0) {\n                this.emit('gameOver');\n            }\n        }\n\n        updateLevel() {\n            const newLevel = Math.floor(this.core.score / 1000) + 1;\n            if (newLevel !== this.core.level) {\n                const oldLevel = this.core.level;\n                this.core.level = newLevel;\n                this.emit('levelChanged', { old: oldLevel, new: this.core.level });\n            }\n        }\n\n        updateFrameCount(deltaTime) {\n            this.core.frameCount++;\n            this.core.lastTime = performance.now();\n        }\n\n        /**\n         * Update overall game state each frame\n         * @param {number} deltaTime - Time elapsed since last update in seconds\n         */\n        update(deltaTime) {\n            // Advance frame counter and timestamp\n            this.updateFrameCount(deltaTime);\n\n            // Update active power-up timers\n            this.updatePowerUps(deltaTime);\n\n            // Recalculate level based on score\n            this.updateLevel();\n        }\n\n        /**\n         * Entity management\n         */\n        addEntity(type, entity) {\n            if (!this.entities[type]) {\n                throw new Error(`Unknown entity type: ${type}`);\n            }\n            \n            this.entities[type].push(entity);\n            this.emit('entityAdded', { type, entity });\n            \n            // Apply entity limits\n            this.enforceEntityLimits(type);\n        }\n\n        removeEntity(type, predicate) {\n            const initialLength = this.entities[type].length;\n            this.entities[type] = this.entities[type].filter(predicate);\n            const removed = initialLength - this.entities[type].length;\n            \n            if (removed > 0) {\n                this.emit('entitiesRemoved', { type, count: removed });\n            }\n            \n            return removed;\n        }\n\n        clearEntities(type) {\n            const count = this.entities[type].length;\n            this.entities[type] = [];\n            \n            if (count > 0) {\n                this.emit('entitiesCleared', { type, count });\n            }\n            \n            return count;\n        }\n\n        enforceEntityLimits(type) {\n            const limits = {\n                ingredients: 25,\n                particles: 20,\n                powerUps: 2,\n                orders: 3\n            };\n\n            const limit = limits[type];\n            if (limit && this.entities[type].length > limit) {\n                const excess = this.entities[type].length - limit;\n                this.entities[type].splice(0, excess); // Remove oldest\n                this.emit('entityLimitEnforced', { type, removed: excess });\n            }\n        }\n\n        getEntityCount(type) {\n            return this.entities[type]?.length || 0;\n        }\n\n        /**\n         * Power-up state management\n         */\n        activatePowerUp(type, duration) {\n            if (!this.powerUps[type]) {\n                throw new Error(`Unknown power-up type: ${type}`);\n            }\n\n            // Deactivate if already active (reset timer)\n            if (this.powerUps[type].active) {\n                this.deactivatePowerUp(type);\n            }\n\n            this.powerUps[type].active = true;\n            this.powerUps[type].timeLeft = duration;\n            \n            this.emit('powerUpActivated', { type, duration });\n        }\n\n        updatePowerUps(deltaTime) {\n            const deltaMs = deltaTime * 1000;\n            \n            Object.entries(this.powerUps).forEach(([type, powerUp]) => {\n                if (powerUp.active) {\n                    powerUp.timeLeft -= deltaMs;\n                    \n                    if (powerUp.timeLeft <= 0) {\n                        this.deactivatePowerUp(type);\n                    }\n                }\n            });\n        }\n\n        deactivatePowerUp(type) {\n            if (this.powerUps[type].active) {\n                this.powerUps[type].active = false;\n                this.powerUps[type].timeLeft = 0;\n                this.emit('powerUpDeactivated', { type });\n            }\n        }\n\n        isPowerUpActive(type) {\n            return this.powerUps[type]?.active || false;\n        }\n\n        getPowerUpTimeLeft(type) {\n            return this.powerUps[type]?.timeLeft || 0;\n        }\n\n        /**\n         * Game state control\n         */\n        startGame() {\n            this.core.running = true;\n            this.core.score = 0;\n            this.core.lives = 3;\n            this.core.combo = 1;\n            this.core.level = 1;\n            this.core.frameCount = 0;\n            \n            // Clear all entities\n            Object.keys(this.entities).forEach(type => {\n                this.clearEntities(type);\n            });\n            \n            // Reset power-ups\n            Object.keys(this.powerUps).forEach(type => {\n                this.deactivatePowerUp(type);\n            });\n            \n            // Reset timing\n            this.timing.lastPowerUpSpawn = 0;\n            this.timing.lastOrderSpawn = 0;\n            this.timing.ingredientSpeed = 4;\n            this.timing.spawnRate = 40;\n            \n            this.emit('gameStarted');\n        }\n\n        endGame() {\n            this.core.running = false;\n            \n            // Save high score\n            if (this.core.score > this.core.highScore) {\n                this.core.highScore = this.core.score;\n                this.saveHighScore();\n            }\n            \n            this.emit('gameEnded', { \n                score: this.core.score, \n                highScore: this.core.highScore \n            });\n        }\n\n        pauseGame() {\n            this.core.running = false;\n            this.emit('gamePaused');\n        }\n\n        resumeGame() {\n            this.core.running = true;\n            this.emit('gameResumed');\n        }\n\n        isRunning() {\n            return this.core.running;\n        }\n\n        /**\n         * High score persistence\n         */\n        loadHighScore() {\n            try {\n                return parseInt(localStorage.getItem('burgerDropHighScore') || '0');\n            } catch (e) {\n                console.warn('Could not load high score from localStorage');\n                return 0;\n            }\n        }\n\n        saveHighScore() {\n            try {\n                localStorage.setItem('burgerDropHighScore', this.core.highScore.toString());\n            } catch (e) {\n                console.warn('Could not save high score to localStorage');\n            }\n        }\n\n        /**\n         * Event system\n         */\n        on(event, callback) {\n            if (!this.listeners.has(event)) {\n                this.listeners.set(event, []);\n            }\n            this.listeners.get(event).push(callback);\n        }\n\n        off(event, callback) {\n            const callbacks = this.listeners.get(event);\n            if (callbacks) {\n                const index = callbacks.indexOf(callback);\n                if (index > -1) {\n                    callbacks.splice(index, 1);\n                }\n            }\n        }\n\n        emit(event, data) {\n            // Add to debug history if enabled\n            if (this.debug.enabled) {\n                this.debug.history.push({\n                    timestamp: Date.now(),\n                    event,\n                    data,\n                    frameCount: this.core.frameCount\n                });\n                \n                // Keep only last 100 events\n                if (this.debug.history.length > 100) {\n                    this.debug.history.shift();\n                }\n            }\n\n            // Emit to listeners\n            const callbacks = this.listeners.get(event);\n            if (callbacks) {\n                callbacks.forEach(callback => {\n                    try {\n                        callback(data);\n                    } catch (error) {\n                        console.error(`Error in event listener for ${event}:`, error);\n                    }\n                });\n            }\n        }\n\n        /**\n         * State validation and debugging\n         */\n        validate() {\n            if (!this.debug.validation) return [];\n            \n            const errors = [];\n            \n            // Core state validation\n            if (this.core.score < 0) errors.push('Score cannot be negative');\n            if (this.core.lives < 0) errors.push('Lives cannot be negative');\n            if (this.core.combo < 1 || this.core.combo > 10) errors.push('Combo must be between 1-10');\n            if (this.core.level < 1) errors.push('Level must be positive');\n            \n            // Entity validation\n            Object.entries(this.entities).forEach(([type, entities]) => {\n                if (!Array.isArray(entities)) {\n                    errors.push(`Entity collection ${type} must be an array`);\n                }\n            });\n            \n            // Power-up validation\n            Object.entries(this.powerUps).forEach(([type, powerUp]) => {\n                if (powerUp.active && powerUp.timeLeft <= 0) {\n                    errors.push(`Active power-up ${type} has invalid timeLeft`);\n                }\n            });\n            \n            return errors;\n        }\n\n        getDebugInfo() {\n            return {\n                core: { ...this.core },\n                entityCounts: Object.fromEntries(\n                    Object.entries(this.entities).map(([type, arr]) => [type, arr.length])\n                ),\n                activePowerUps: Object.fromEntries(\n                    Object.entries(this.powerUps)\n                        .filter(([_, powerUp]) => powerUp.active)\n                        .map(([type, powerUp]) => [type, powerUp.timeLeft])\n                ),\n                ui: { ...this.ui },\n                timing: { ...this.timing },\n                listenerCounts: Object.fromEntries(\n                    Array.from(this.listeners.entries())\n                        .map(([event, callbacks]) => [event, callbacks.length])\n                ),\n                errors: this.validate()\n            };\n        }\n\n        enableDebug() {\n            this.debug.enabled = true;\n            this.debug.validation = true;\n            console.log('GameState debugging enabled');\n        }\n\n        disableDebug() {\n            this.debug.enabled = false;\n            this.debug.validation = false;\n            this.debug.history = [];\n            console.log('GameState debugging disabled');\n        }\n\n        getDebugHistory() {\n            return [...this.debug.history];\n        }\n    }\n\n    /**\n     * Easing Functions Collection\n     * \n     * Mathematical easing functions for smooth animations and transitions.\n     * All functions take a parameter t (0 to 1) and return the eased value.\n     */\n\n    const easing = {\n        /**\n         * Linear interpolation - no easing\n         * @param {number} t - Progress value (0 to 1)\n         * @returns {number} Eased value\n         */\n        linear: t => t,\n\n        /**\n         * Quadratic ease-in - starts slow, accelerates\n         * @param {number} t - Progress value (0 to 1)\n         * @returns {number} Eased value\n         */\n        easeInQuad: t => t * t,\n\n        /**\n         * Quadratic ease-out - starts fast, decelerates\n         * @param {number} t - Progress value (0 to 1)\n         * @returns {number} Eased value\n         */\n        easeOutQuad: t => t * (2 - t),\n\n        /**\n         * Quadratic ease-in-out - slow start and end, fast middle\n         * @param {number} t - Progress value (0 to 1)\n         * @returns {number} Eased value\n         */\n        easeInOutQuad: t => t < 0.5 ? 2 * t * t : -1 + (4 - 2 * t) * t,\n\n        /**\n         * Cubic ease-in - starts very slow, accelerates strongly\n         * @param {number} t - Progress value (0 to 1)\n         * @returns {number} Eased value\n         */\n        easeInCubic: t => t * t * t,\n\n        /**\n         * Cubic ease-out - starts fast, decelerates strongly\n         * @param {number} t - Progress value (0 to 1)\n         * @returns {number} Eased value\n         */\n        easeOutCubic: t => (--t) * t * t + 1,\n\n        /**\n         * Cubic ease-in-out - very slow start and end, very fast middle\n         * @param {number} t - Progress value (0 to 1)\n         * @returns {number} Eased value\n         */\n        easeInOutCubic: t => t < 0.5 ? 4 * t * t * t : (t - 1) * (2 * t - 2) * (2 * t - 2) + 1,\n\n        /**\n         * Elastic ease-in - spring-like effect at the beginning\n         * @param {number} t - Progress value (0 to 1)\n         * @returns {number} Eased value\n         */\n        easeInElastic: t => {\n            if (t === 0 || t === 1) return t;\n            const p = 0.3;\n            const s = p / 4;\n            return -(Math.pow(2, 10 * (t -= 1)) * Math.sin((t - s) * (2 * Math.PI) / p));\n        },\n\n        /**\n         * Elastic ease-out - spring-like effect at the end\n         * @param {number} t - Progress value (0 to 1)\n         * @returns {number} Eased value\n         */\n        easeOutElastic: t => {\n            if (t === 0 || t === 1) return t;\n            const p = 0.3;\n            const s = p / 4;\n            return Math.pow(2, -10 * t) * Math.sin((t - s) * (2 * Math.PI) / p) + 1;\n        },\n\n        /**\n         * Bounce ease-out - bouncing ball effect at the end\n         * @param {number} t - Progress value (0 to 1)\n         * @returns {number} Eased value\n         */\n        easeOutBounce: t => {\n            if (t < 1 / 2.75) {\n                return 7.5625 * t * t;\n            } else if (t < 2 / 2.75) {\n                return 7.5625 * (t -= 1.5 / 2.75) * t + 0.75;\n            } else if (t < 2.5 / 2.75) {\n                return 7.5625 * (t -= 2.25 / 2.75) * t + 0.9375;\n            } else {\n                return 7.5625 * (t -= 2.625 / 2.75) * t + 0.984375;\n            }\n        }\n    };\n\n    // Define easeInBounce after easeOutBounce is defined\n    easing.easeInBounce = t => 1 - easing.easeOutBounce(1 - t);\n\n    /**\n     * Particle Entity\n     * \n     * Represents visual effect particles with physics simulation.\n     * Supports multiple types: default, celebration, star, circle, triangle.\n     * Includes gravity, bouncing, rotation, and easing animations.\n     */\n\n\n    class Particle {\n        /**\n         * Create a new particle\n         * @param {number} x - Initial x position\n         * @param {number} y - Initial y position\n         * @param {string} color - Particle color\n         * @param {string} text - Optional text/emoji to display\n         * @param {string} type - Particle type ('default', 'celebration', 'star', 'circle', 'triangle')\n         * @param {object} options - Additional options\n         */\n        constructor(x = 0, y = 0, color = '#FFFFFF', text = '', type = 'default', options = {}) {\n            this.init(x, y, color, text, type, options);\n        }\n        \n        /**\n         * Initialize/reset particle properties (used for object pooling)\n         * @param {number} x - Initial x position\n         * @param {number} y - Initial y position\n         * @param {string} color - Particle color\n         * @param {string} text - Optional text/emoji to display\n         * @param {string} type - Particle type\n         * @param {object} options - Additional options\n         */\n        init(x = 0, y = 0, color = '#FFFFFF', text = '', type = 'default', options = {}) {\n            this.x = x;\n            this.y = y;\n            this.vx = options.vx || (Math.random() - 0.5) * 6;\n            this.vy = options.vy || (-Math.random() * 6 - 3);\n            this.color = color;\n            this.text = text;\n            this.life = 1;\n            this.decay = options.decay || 0.015;\n            this.type = type;\n            this.size = options.size || (Math.random() * 3 + 2);\n            this.rotation = Math.random() * Math.PI * 2;\n            this.rotationSpeed = (Math.random() - 0.5) * 0.2;\n            this.gravity = options.gravity || 0.15;\n            this.bounce = options.bounce || 0.7;\n            this.scale = 1;\n            this.startTime = 0; // Will be set when added to game\n            this.duration = options.duration || (60 + Math.random() * 60); // 1-2 seconds at 60fps\n            \n            // Store canvas dimensions for boundary checks\n            this.canvasWidth = options.canvasWidth || 800;\n            this.canvasHeight = options.canvasHeight || 600;\n            \n            // Pool-friendly properties\n            this.pooled = false;\n            \n            return this;\n        }\n\n        /**\n         * Update particle state\n         * @param {number} frameCount - Current frame count for timing\n         * @param {number} deltaTime - Time elapsed since last frame (optional)\n         */\n        update(frameCount, deltaTime = 1/60) {\n            // Set start time on first update\n            if (this.startTime === 0) {\n                this.startTime = frameCount;\n            }\n            \n            const elapsed = frameCount - this.startTime;\n            const progress = Math.min(elapsed / this.duration, 1);\n            \n            // Physics update\n            this.x += this.vx * deltaTime * 60; // Scale by target framerate\n            this.y += this.vy * deltaTime * 60;\n            this.vy += this.gravity;\n            this.rotation += this.rotationSpeed;\n            \n            // Use custom easing for life decay\n            this.life = 1 - easing.easeOutQuad(progress);\n            \n            // Bounce off ground with easing\n            if (this.y > this.canvasHeight - 10 && this.vy > 0) {\n                this.vy *= -this.bounce;\n                this.vx *= 0.8;\n            }\n            \n            // Enhanced scale animation for celebration particles\n            if (this.type === 'celebration') {\n                const pulseProgress = (frameCount * 0.1 + this.x) % (Math.PI * 2);\n                this.scale = 0.7 + easing.easeInOutCubic(Math.sin(pulseProgress) * 0.5 + 0.5) * 0.6;\n            }\n        }\n\n        /**\n         * Render the particle\n         * @param {CanvasRenderingContext2D} ctx - Canvas rendering context\n         */\n        draw(ctx) {\n            ctx.save();\n            ctx.globalAlpha = this.life;\n            ctx.translate(this.x, this.y);\n            ctx.rotate(this.rotation);\n            ctx.scale(this.scale, this.scale);\n            \n            if (this.text) {\n                ctx.font = `bold ${20 + this.size * 2}px Arial`; // Keep Arial for emoji compatibility\n                ctx.fillStyle = this.color;\n                ctx.textAlign = 'center';\n                ctx.textBaseline = 'middle';\n                \n                // Add glow effect for special particles\n                if (this.type === 'celebration') {\n                    ctx.shadowColor = this.color;\n                    ctx.shadowBlur = 10;\n                }\n                \n                ctx.fillText(this.text, 0, 0);\n            } else {\n                // Different shapes based on type\n                ctx.fillStyle = this.color;\n                \n                switch(this.type) {\n                    case 'star':\n                        this.drawStar(ctx);\n                        break;\n                    case 'circle':\n                        ctx.beginPath();\n                        ctx.arc(0, 0, this.size, 0, Math.PI * 2);\n                        ctx.fill();\n                        break;\n                    case 'triangle':\n                        ctx.beginPath();\n                        ctx.moveTo(0, -this.size);\n                        ctx.lineTo(-this.size, this.size);\n                        ctx.lineTo(this.size, this.size);\n                        ctx.closePath();\n                        ctx.fill();\n                        break;\n                    default:\n                        ctx.fillRect(-this.size/2, -this.size/2, this.size, this.size);\n                }\n            }\n            ctx.restore();\n        }\n        \n        /**\n         * Draw a star shape\n         * @param {CanvasRenderingContext2D} ctx - Canvas rendering context\n         */\n        drawStar(ctx) {\n            const spikes = 5;\n            const outerRadius = this.size;\n            const innerRadius = this.size * 0.4;\n            \n            ctx.beginPath();\n            for (let i = 0; i < spikes; i++) {\n                const angle = (i * Math.PI * 2) / spikes;\n                const x = Math.cos(angle) * outerRadius;\n                const y = Math.sin(angle) * outerRadius;\n                \n                if (i === 0) ctx.moveTo(x, y);\n                else ctx.lineTo(x, y);\n                \n                const innerAngle = angle + Math.PI / spikes;\n                const innerX = Math.cos(innerAngle) * innerRadius;\n                const innerY = Math.sin(innerAngle) * innerRadius;\n                ctx.lineTo(innerX, innerY);\n            }\n            ctx.closePath();\n            ctx.fill();\n        }\n\n        /**\n         * Check if particle is still alive\n         * @returns {boolean} True if particle should continue existing\n         */\n        isAlive() {\n            return this.life > 0.01;\n        }\n        \n        /**\n         * Reset particle for object pooling\n         * @param {number} x - Initial x position\n         * @param {number} y - Initial y position\n         * @param {string} color - Particle color\n         * @param {string} text - Optional text/emoji to display\n         * @param {string} type - Particle type\n         * @param {object} options - Additional options\n         */\n        reset(x, y, color, text = '', type = 'default', options = {}) {\n            this.x = x;\n            this.y = y;\n            this.vx = options.vx || (Math.random() - 0.5) * 6;\n            this.vy = options.vy || (-Math.random() * 6 - 3);\n            this.color = color;\n            this.text = text;\n            this.life = 1;\n            this.decay = options.decay || 0.015;\n            this.type = type;\n            this.size = options.size || (Math.random() * 3 + 2);\n            this.rotation = Math.random() * Math.PI * 2;\n            this.rotationSpeed = (Math.random() - 0.5) * 0.2;\n            this.gravity = options.gravity || 0.15;\n            this.bounce = options.bounce || 0.7;\n            this.scale = 1;\n            this.startTime = 0;\n            this.duration = options.duration || (60 + Math.random() * 60);\n            \n            // Update canvas dimensions if provided\n            if (options.canvasWidth) this.canvasWidth = options.canvasWidth;\n            if (options.canvasHeight) this.canvasHeight = options.canvasHeight;\n        }\n\n        /**\n         * Get particle bounds for collision detection\n         * @returns {object} Bounds object {x, y, width, height}\n         */\n        getBounds() {\n            const radius = this.size * this.scale;\n            return {\n                x: this.x - radius,\n                y: this.y - radius,\n                width: radius * 2,\n                height: radius * 2\n            };\n        }\n\n        /**\n         * Update canvas dimensions for boundary calculations\n         * @param {number} width - Canvas width\n         * @param {number} height - Canvas height\n         */\n        updateCanvasDimensions(width, height) {\n            this.canvasWidth = width;\n            this.canvasHeight = height;\n        }\n\n        /**\n         * Create a celebration particle with predefined settings\n         * @param {number} x - X position\n         * @param {number} y - Y position\n         * @param {string} color - Particle color\n         * @param {string} emoji - Emoji to display\n         * @returns {Particle} New celebration particle\n         */\n        static createCelebration(x, y, color, emoji = '‚ú®') {\n            return new Particle(x, y, color, emoji, 'celebration', {\n                vx: (Math.random() - 0.5) * 8,\n                vy: -Math.random() * 8 - 5,\n                size: Math.random() * 4 + 3,\n                duration: 90 + Math.random() * 60, // Longer duration for celebration\n                gravity: 0.1, // Lighter gravity for floating effect\n                bounce: 0.9\n            });\n        }\n\n        /**\n         * Create an explosion of particles\n         * @param {number} x - Explosion center X\n         * @param {number} y - Explosion center Y\n         * @param {string} color - Particle color\n         * @param {number} count - Number of particles to create\n         * @param {string} type - Particle type\n         * @returns {Array<Particle>} Array of explosion particles\n         */\n        static createExplosion(x, y, color, count = 10, type = 'star') {\n            const particles = [];\n            \n            for (let i = 0; i < count; i++) {\n                const angle = (i / count) * Math.PI * 2;\n                const speed = Math.random() * 6 + 3;\n                const vx = Math.cos(angle) * speed;\n                const vy = Math.sin(angle) * speed - 2; // Slight upward bias\n                \n                particles.push(new Particle(x, y, color, '', type, {\n                    vx,\n                    vy,\n                    size: Math.random() * 3 + 1,\n                    duration: 45 + Math.random() * 30,\n                    gravity: 0.2\n                }));\n            }\n            \n            return particles;\n        }\n\n        /**\n         * Reset function for object pooling\n         * @param {Particle} particle - Particle to reset\n         * @param {number} x - Initial x position\n         * @param {number} y - Initial y position\n         * @param {string} color - Particle color\n         * @param {string} text - Optional text/emoji to display\n         * @param {string} type - Particle type\n         * @param {object} options - Additional options\n         */\n        static resetParticle(particle, x, y, color, text = '', type = 'default', options = {}) {\n            particle.init(x, y, color, text, type, options);\n        }\n        \n        /**\n         * Create particle factory function for object pooling\n         * @returns {Function} Factory function that creates new particles\n         */\n        static createFactory() {\n            return () => new Particle();\n        }\n        \n        /**\n         * Create floating text particle\n         * @param {number} x - X position\n         * @param {number} y - Y position\n         * @param {string} text - Text to display\n         * @param {string} color - Text color\n         * @returns {Particle} New text particle\n         */\n        static createFloatingText(x, y, text, color = '#FFD700') {\n            return new Particle(x, y, color, text, 'text', {\n                vx: (Math.random() - 0.5) * 2,\n                vy: -2 - Math.random() * 2,\n                size: 0, // Size is handled by font size\n                duration: 120, // 2 seconds\n                gravity: 0, // Text floats up\n                bounce: 0\n            });\n        }\n    }\n\n    /**\n     * PowerUp Entity\n     * \n     * Represents collectible power-ups that provide temporary game advantages.\n     * Supports multiple types: speedBoost (slow motion), timeFreeze, and scoreMultiplier.\n     */\n\n    /**\n     * Power-up type configurations\n     */\n    const powerUpTypes = {\n        speedBoost: {\n            emoji: 'üêå',\n            name: 'Slow Motion',\n            color: '#FFD700',\n            duration: 8000, // 8 seconds\n            description: 'Slows ingredient fall speed'\n        },\n        timeFreeze: {\n            emoji: '‚ùÑÔ∏è',\n            name: 'Time Freeze',\n            color: '#87CEEB',\n            duration: 5000, // 5 seconds\n            description: 'Freezes order timers'\n        },\n        scoreMultiplier: {\n            emoji: 'üíé',\n            name: 'Score Boost',\n            color: '#FF69B4',\n            duration: 10000, // 10 seconds\n            description: 'Double score points'\n        }\n    };\n\n    class PowerUp {\n        /**\n         * Create a new power-up\n         * @param {string} type - Power-up type ('speedBoost', 'timeFreeze', 'scoreMultiplier')\n         * @param {object} options - Additional options\n         */\n        constructor(type, options = {}) {\n            this.type = type;\n            this.data = powerUpTypes[type];\n            \n            if (!this.data) {\n                throw new Error(`Unknown power-up type: ${type}`);\n            }\n            \n            this.x = options.x !== undefined ? options.x : Math.random() * (options.canvasWidth || 800 - 50);\n            this.y = options.y !== undefined ? options.y : -50;\n            this.speed = options.speed || 1.5; // Fixed speed for consistency\n            this.collected = false;\n            this.size = options.size || 40;\n            this.cachedFont = null; // Cache font for performance\n            \n            // Store canvas dimensions for boundary calculations\n            this.canvasWidth = options.canvasWidth || 800;\n            this.canvasHeight = options.canvasHeight || 600;\n            \n            // Animation properties\n            this.animationTime = 0;\n            this.pulseIntensity = options.pulseIntensity || 0.1;\n        }\n        \n        /**\n         * Update power-up state\n         * @param {number} deltaTime - Time elapsed since last frame\n         */\n        update(deltaTime = 1/60) {\n            this.y += this.speed * deltaTime * 60; // Scale by target framerate\n            this.animationTime += deltaTime;\n        }\n        \n        /**\n         * Render the power-up\n         * @param {CanvasRenderingContext2D} ctx - Canvas rendering context\n         */\n        draw(ctx) {\n            // Pre-calculate position\n            const centerX = this.x + this.size/2;\n            const centerY = this.y + this.size/2;\n            \n            // Add subtle pulsing animation\n            const pulse = 1 + Math.sin(this.animationTime * 4) * this.pulseIntensity;\n            const currentSize = this.size * pulse;\n            \n            ctx.save();\n            \n            // Draw glow effect\n            ctx.shadowColor = this.data.color;\n            ctx.shadowBlur = 10;\n            \n            // Main circle\n            ctx.fillStyle = this.data.color;\n            ctx.beginPath();\n            ctx.arc(centerX, centerY, currentSize/2, 0, Math.PI * 2);\n            ctx.fill();\n            \n            // Border\n            ctx.shadowBlur = 0;\n            ctx.strokeStyle = '#FFFFFF';\n            ctx.lineWidth = 2;\n            ctx.stroke();\n            \n            // Emoji (cached font for performance)\n            if (!this.cachedFont) {\n                this.cachedFont = `${this.size * 0.6}px Arial`;\n            }\n            ctx.font = this.cachedFont;\n            ctx.textAlign = 'center';\n            ctx.textBaseline = 'middle';\n            ctx.fillStyle = '#FFFFFF';\n            ctx.shadowColor = 'rgba(0, 0, 0, 0.5)';\n            ctx.shadowBlur = 2;\n            ctx.shadowOffsetX = 1;\n            ctx.shadowOffsetY = 1;\n            ctx.fillText(this.data.emoji, centerX, centerY);\n            \n            ctx.restore();\n        }\n        \n        /**\n         * Check if coordinates are within the power-up's clickable area\n         * @param {number} x - X coordinate\n         * @param {number} y - Y coordinate\n         * @returns {boolean} True if clicked\n         */\n        isClicked(x, y) {\n            const centerX = this.x + this.size/2;\n            const centerY = this.y + this.size/2;\n            const distance = Math.sqrt((x - centerX) ** 2 + (y - centerY) ** 2);\n            return distance <= this.size/2;\n        }\n        \n        /**\n         * Check if power-up is off screen (should be removed)\n         * @returns {boolean} True if off screen\n         */\n        isOffScreen() {\n            return this.y > this.canvasHeight + this.size;\n        }\n        \n        /**\n         * Get power-up bounds for collision detection\n         * @returns {object} Bounds object {x, y, width, height}\n         */\n        getBounds() {\n            return {\n                x: this.x,\n                y: this.y,\n                width: this.size,\n                height: this.size\n            };\n        }\n        \n        /**\n         * Get the center point of the power-up\n         * @returns {object} Center coordinates {x, y}\n         */\n        getCenter() {\n            return {\n                x: this.x + this.size/2,\n                y: this.y + this.size/2\n            };\n        }\n        \n        /**\n         * Mark power-up as collected\n         */\n        collect() {\n            this.collected = true;\n        }\n        \n        /**\n         * Check if power-up has been collected\n         * @returns {boolean} True if collected\n         */\n        isCollected() {\n            return this.collected;\n        }\n        \n        /**\n         * Get power-up duration in milliseconds\n         * @returns {number} Duration in milliseconds\n         */\n        getDuration() {\n            return this.data.duration;\n        }\n        \n        /**\n         * Get power-up description\n         * @returns {string} Human-readable description\n         */\n        getDescription() {\n            return this.data.description;\n        }\n        \n        /**\n         * Update canvas dimensions for boundary calculations\n         * @param {number} width - Canvas width\n         * @param {number} height - Canvas height\n         */\n        updateCanvasDimensions(width, height) {\n            this.canvasWidth = width;\n            this.canvasHeight = height;\n        }\n        \n        /**\n         * Create a random power-up\n         * @param {object} options - Options for power-up creation\n         * @returns {PowerUp} New random power-up\n         */\n        static createRandom(options = {}) {\n            const types = Object.keys(powerUpTypes);\n            const randomType = types[Math.floor(Math.random() * types.length)];\n            return new PowerUp(randomType, options);\n        }\n        \n        /**\n         * Get all available power-up types\n         * @returns {Array<string>} Array of power-up type names\n         */\n        static getAvailableTypes() {\n            return Object.keys(powerUpTypes);\n        }\n        \n        /**\n         * Get power-up type configuration\n         * @param {string} type - Power-up type\n         * @returns {object} Type configuration or null if not found\n         */\n        static getTypeConfig(type) {\n            return powerUpTypes[type] || null;\n        }\n        \n        /**\n         * Validate if a type is valid\n         * @param {string} type - Power-up type to validate\n         * @returns {boolean} True if valid type\n         */\n        static isValidType(type) {\n            return type in powerUpTypes;\n        }\n    }\n\n    /**\n     * Ingredient Entity\n     * \n     * Represents falling burger ingredients with physics simulation, trail effects,\n     * and visual variants. Includes integration with power-up system.\n     */\n\n\n    /**\n     * Ingredient type configurations\n     */\n    const ingredientTypes = {\n        bun_top: { \n            emoji: 'üçû', \n            variants: ['üçû', 'ü•ñ'], \n            name: 'Top Bun', \n            size: 40,\n            color: '#D2B48C'\n        },\n        bun_bottom: { \n            emoji: 'ü•ñ', \n            variants: ['ü•ñ', 'üçû'], \n            name: 'Bottom Bun', \n            size: 40,\n            color: '#DEB887'\n        },\n        patty: { \n            emoji: 'ü•©', \n            variants: ['ü•©', 'üçñ'], \n            name: 'Patty', \n            size: 45,\n            color: '#8B4513'\n        },\n        cheese: { \n            emoji: 'üßÄ', \n            variants: ['üßÄ', 'üü®'], \n            name: 'Cheese', \n            size: 35,\n            color: '#FFD700'\n        },\n        lettuce: { \n            emoji: 'ü•¨', \n            variants: ['ü•¨', 'üçÉ'], \n            name: 'Lettuce', \n            size: 35,\n            color: '#90EE90'\n        },\n        tomato: { \n            emoji: 'üçÖ', \n            variants: ['üçÖ', 'üî¥'], \n            name: 'Tomato', \n            size: 35,\n            color: '#FF6347'\n        },\n        pickle: { \n            emoji: 'ü•í', \n            variants: ['ü•í', 'üü¢'], \n            name: 'Pickle', \n            size: 30,\n            color: '#9ACD32'\n        },\n        bacon: { \n            emoji: 'ü•ì', \n            variants: ['ü•ì', 'üî•'], \n            name: 'Bacon', \n            size: 35,\n            color: '#DC143C'\n        },\n        onion: { \n            emoji: 'üßÖ', \n            variants: ['üßÖ', '‚ö™'], \n            name: 'Onion', \n            size: 30,\n            color: '#F5F5DC'\n        },\n        egg: { \n            emoji: 'üç≥', \n            variants: ['üç≥', 'üü°'], \n            name: 'Egg', \n            size: 40,\n            color: '#FFFFE0'\n        }\n    };\n\n    class Ingredient {\n        /**\n         * Create a new ingredient\n         * @param {string} type - Ingredient type key from ingredientTypes\n         * @param {object} options - Additional options\n         */\n        constructor(type = 'bun_top', options = {}) {\n            this.init(type, options);\n        }\n        \n        /**\n         * Initialize/reset ingredient properties (used for object pooling)\n         * @param {string} type - Ingredient type key from ingredientTypes\n         * @param {object} options - Additional options\n         */\n        init(type, options = {}) {\n            this.type = type;\n            this.data = ingredientTypes[type];\n            \n            if (!this.data) {\n                throw new Error(`Unknown ingredient type: ${type}`);\n            }\n            \n            // Position and movement\n            this.x = options.x !== undefined ? options.x : Math.random() * (options.canvasWidth || 800 - this.data.size);\n            this.y = options.y !== undefined ? options.y : -this.data.size;\n            \n            // Speed calculation with variation\n            const baseSpeed = options.baseSpeed || 4;\n            const speedVariation = Math.random() * 4 - 2; // ¬±2 variation\n            const speedMultiplier = Math.random() < 0.1 ? (Math.random() < 0.5 ? 0.4 : 2.2) : 1; // 10% chance of very slow/fast\n            this.speed = (baseSpeed + speedVariation) * speedMultiplier;\n            this.baseSpeed = this.speed;\n            \n            // Rotation\n            this.rotation = Math.random() * Math.PI * 2;\n            this.rotationSpeed = (Math.random() - 0.5) * 0.1;\n            \n            // State\n            this.collected = false;\n            this.startY = this.y;\n            this.fallProgress = 0;\n            this.sway = Math.random() * 2 - 1; // -1 to 1 for horizontal sway\n            \n            // Trail system\n            this.trail = [];\n            this.maxTrailLength = options.maxTrailLength || 8;\n            this.trailUpdateInterval = options.trailUpdateInterval || 3;\n            this.trailCounter = 0;\n            \n            // Animation timing\n            this.animationTime = 0;\n            \n            // Canvas dimensions for boundary checks\n            this.canvasWidth = options.canvasWidth || 800;\n            this.canvasHeight = options.canvasHeight || 600;\n        }\n\n        /**\n         * Update ingredient state\n         * @param {number} frameCount - Current frame count for timing\n         * @param {object} gameState - Game state for power-up checks\n         * @param {number} deltaTime - Time elapsed since last frame\n         */\n        update(frameCount, gameState, deltaTime = 1/60) {\n            this.animationTime += deltaTime;\n            \n            // Apply speed boost power-up if available\n            let speedMultiplier = 1;\n            if (gameState && gameState.isPowerUpActive && gameState.isPowerUpActive('speedBoost')) {\n                speedMultiplier = gameState.powerUps.speedBoost.multiplier;\n            }\n            this.speed = this.baseSpeed * speedMultiplier;\n            \n            // Smooth falling motion with easing\n            this.fallProgress += 0.02;\n            const fallEase = easing.easeInQuad(Math.min(this.fallProgress, 1));\n            this.y += this.speed * (0.5 + fallEase * 0.5) * deltaTime * 60;\n            \n            // Add subtle horizontal sway\n            const swayAmount = Math.sin(frameCount * 0.05 + this.sway * Math.PI) * 0.5;\n            this.x += swayAmount * deltaTime * 60;\n            \n            // Smooth rotation with easing\n            this.rotation += this.rotationSpeed * (1 + fallEase * 0.5);\n            \n            // Update trail\n            this.trailCounter++;\n            if (this.trailCounter >= this.trailUpdateInterval) {\n                this.trail.push({\n                    x: this.x + this.data.size / 2,\n                    y: this.y + this.data.size / 2,\n                    alpha: 1,\n                    size: this.data.size * 0.8\n                });\n                \n                if (this.trail.length > this.maxTrailLength) {\n                    this.trail.shift();\n                }\n                \n                this.trailCounter = 0;\n            }\n            \n            // Update trail alpha with easing\n            this.trail.forEach((point, index) => {\n                const trailProgress = (index + 1) / this.trail.length;\n                point.alpha = easing.easeOutCubic(trailProgress) * 0.6;\n                point.size *= 0.98;\n            });\n        }\n\n        /**\n         * Render the ingredient\n         * @param {CanvasRenderingContext2D} ctx - Canvas rendering context\n         * @param {number} frameCount - Current frame count for animations\n         * @param {object} colorTheme - Color theme for effects\n         */\n        draw(ctx, frameCount, colorTheme) {\n            // Draw trail first (behind ingredient)\n            this.drawTrail(ctx, colorTheme);\n            \n            ctx.save();\n            ctx.translate(this.x + this.data.size / 2, this.y + this.data.size / 2);\n            ctx.rotate(this.rotation);\n            \n            // Add enhanced shadow to ingredients\n            ctx.shadowColor = 'rgba(0, 0, 0, 0.4)';\n            ctx.shadowBlur = 6;\n            ctx.shadowOffsetX = 3;\n            ctx.shadowOffsetY = 3;\n            \n            // Use enhanced emoji with occasional variants\n            const useVariant = frameCount % 120 < 10; // Show variant for 10 frames every 2 seconds\n            const emojiToUse = useVariant && this.data.variants ? \n                this.data.variants[Math.floor(frameCount / 30) % this.data.variants.length] : \n                this.data.emoji;\n            \n            ctx.font = `${this.data.size}px Arial`; // Keep Arial for emoji compatibility\n            ctx.textAlign = 'center';\n            ctx.textBaseline = 'middle';\n            ctx.fillText(emojiToUse, 0, 0);\n            ctx.restore();\n        }\n        \n        /**\n         * Draw the trail effect behind the ingredient\n         * @param {CanvasRenderingContext2D} ctx - Canvas rendering context\n         * @param {object} colorTheme - Color theme for trail colors\n         */\n        drawTrail(ctx, colorTheme) {\n            if (this.trail.length < 2) return;\n            \n            ctx.save();\n            \n            // Create gradient trail effect\n            for (let i = 0; i < this.trail.length - 1; i++) {\n                const point = this.trail[i];\n                const nextPoint = this.trail[i + 1];\n                \n                // Draw line segment with gradient\n                const gradient = ctx.createLinearGradient(\n                    point.x, point.y, nextPoint.x, nextPoint.y\n                );\n                gradient.addColorStop(0, `rgba(255, 255, 255, ${point.alpha * 0.3})`);\n                gradient.addColorStop(1, `rgba(255, 255, 255, ${nextPoint.alpha * 0.3})`);\n                \n                ctx.strokeStyle = gradient;\n                ctx.lineWidth = Math.max(point.size * 0.15, 1);\n                ctx.lineCap = 'round';\n                \n                ctx.beginPath();\n                ctx.moveTo(point.x, point.y);\n                ctx.lineTo(nextPoint.x, nextPoint.y);\n                ctx.stroke();\n            }\n            \n            // Draw trail points\n            this.trail.forEach(point => {\n                ctx.globalAlpha = point.alpha * 0.4;\n                \n                // Use accent color from theme or fallback\n                const accentColor = colorTheme?.accent || '#00FF88';\n                ctx.fillStyle = accentColor + '80'; // Add transparency\n                \n                ctx.beginPath();\n                ctx.arc(point.x, point.y, Math.max(point.size * 0.1, 2), 0, Math.PI * 2);\n                ctx.fill();\n            });\n            \n            ctx.restore();\n        }\n\n        /**\n         * Check if coordinates are within the ingredient's clickable area\n         * @param {number} x - X coordinate\n         * @param {number} y - Y coordinate\n         * @returns {boolean} True if clicked\n         */\n        isClicked(x, y) {\n            return x >= this.x && x <= this.x + this.data.size &&\n                   y >= this.y && y <= this.y + this.data.size;\n        }\n        \n        /**\n         * Check if ingredient is off screen (should be removed)\n         * @returns {boolean} True if off screen\n         */\n        isOffScreen() {\n            return this.y > this.canvasHeight + this.data.size;\n        }\n        \n        /**\n         * Get ingredient bounds for collision detection\n         * @returns {object} Bounds object {x, y, width, height}\n         */\n        getBounds() {\n            return {\n                x: this.x,\n                y: this.y,\n                width: this.data.size,\n                height: this.data.size\n            };\n        }\n        \n        /**\n         * Get the center point of the ingredient\n         * @returns {object} Center coordinates {x, y}\n         */\n        getCenter() {\n            return {\n                x: this.x + this.data.size / 2,\n                y: this.y + this.data.size / 2\n            };\n        }\n        \n        /**\n         * Mark ingredient as collected\n         */\n        collect() {\n            this.collected = true;\n        }\n        \n        /**\n         * Check if ingredient has been collected\n         * @returns {boolean} True if collected\n         */\n        isCollected() {\n            return this.collected;\n        }\n        \n        /**\n         * Get ingredient name\n         * @returns {string} Human-readable ingredient name\n         */\n        getName() {\n            return this.data.name;\n        }\n        \n        /**\n         * Get ingredient color\n         * @returns {string} Ingredient color\n         */\n        getColor() {\n            return this.data.color;\n        }\n        \n        /**\n         * Update canvas dimensions for boundary calculations\n         * @param {number} width - Canvas width\n         * @param {number} height - Canvas height\n         */\n        updateCanvasDimensions(width, height) {\n            this.canvasWidth = width;\n            this.canvasHeight = height;\n        }\n        \n        /**\n         * Reset ingredient for object pooling\n         * @param {string} type - Ingredient type key from ingredientTypes\n         * @param {object} options - Additional options\n         */\n        reset(type, options = {}) {\n            this.type = type;\n            this.data = ingredientTypes[type];\n            \n            if (!this.data) {\n                throw new Error(`Unknown ingredient type: ${type}`);\n            }\n            \n            // Position and movement\n            this.x = options.x !== undefined ? options.x : Math.random() * ((options.canvasWidth || this.canvasWidth || 800) - this.data.size);\n            this.y = options.y !== undefined ? options.y : -this.data.size;\n            \n            // Speed calculation with variation\n            const baseSpeed = options.baseSpeed || 4;\n            const speedVariation = Math.random() * 4 - 2;\n            const speedMultiplier = Math.random() < 0.1 ? (Math.random() < 0.5 ? 0.4 : 2.2) : 1;\n            this.speed = (baseSpeed + speedVariation) * speedMultiplier;\n            this.baseSpeed = this.speed;\n            \n            // Rotation\n            this.rotation = Math.random() * Math.PI * 2;\n            this.rotationSpeed = (Math.random() - 0.5) * 0.1;\n            \n            // State\n            this.collected = false;\n            this.startY = this.y;\n            this.fallProgress = 0;\n            this.sway = Math.random() * 2 - 1;\n            \n            // Trail system\n            this.trail = [];\n            this.maxTrailLength = options.maxTrailLength || 8;\n            this.trailUpdateInterval = options.trailUpdateInterval || 3;\n            this.trailCounter = 0;\n            \n            // Animation timing\n            this.animationTime = 0;\n            \n            // Update canvas dimensions if provided\n            if (options.canvasWidth) this.canvasWidth = options.canvasWidth;\n            if (options.canvasHeight) this.canvasHeight = options.canvasHeight;\n        }\n        \n        /**\n         * Create a random ingredient\n         * @param {object} options - Options for ingredient creation\n         * @returns {Ingredient} New random ingredient\n         */\n        static createRandom(options = {}) {\n            const types = Object.keys(ingredientTypes);\n            const randomType = types[Math.floor(Math.random() * types.length)];\n            return new Ingredient(randomType, options);\n        }\n        \n        /**\n         * Get all available ingredient types\n         * @returns {Array<string>} Array of ingredient type names\n         */\n        static getAvailableTypes() {\n            return Object.keys(ingredientTypes);\n        }\n        \n        /**\n         * Get ingredient type configuration\n         * @param {string} type - Ingredient type\n         * @returns {object} Type configuration or null if not found\n         */\n        static getTypeConfig(type) {\n            return ingredientTypes[type] || null;\n        }\n        \n        /**\n         * Validate if a type is valid\n         * @param {string} type - Ingredient type to validate\n         * @returns {boolean} True if valid type\n         */\n        static isValidType(type) {\n            return type in ingredientTypes;\n        }\n    }\n\n    /**\n     * Order Entity\n     * \n     * Represents customer orders with time limits and ingredient tracking.\n     * Includes visual rendering with progress indication and timer management.\n     */\n\n\n    /**\n     * Order template configurations\n     */\n    const orderTemplates = [\n        { name: 'Classic Burger', ingredients: ['bun_bottom', 'patty', 'cheese', 'lettuce', 'tomato', 'bun_top'], time: 30 },\n        { name: 'Simple Burger', ingredients: ['bun_bottom', 'patty', 'bun_top'], time: 20 },\n        { name: 'Cheese Burger', ingredients: ['bun_bottom', 'patty', 'cheese', 'bun_top'], time: 25 },\n        { name: 'Veggie Burger', ingredients: ['bun_bottom', 'lettuce', 'tomato', 'onion', 'pickle', 'bun_top'], time: 30 },\n        { name: 'Bacon Burger', ingredients: ['bun_bottom', 'patty', 'bacon', 'cheese', 'bun_top'], time: 35 },\n        { name: 'Breakfast Burger', ingredients: ['bun_bottom', 'patty', 'egg', 'bacon', 'cheese', 'bun_top'], time: 40 }\n    ];\n\n    class Order {\n        /**\n         * Create a new order\n         * @param {object} template - Order template with name, ingredients, and time\n         * @param {object} options - Additional options\n         */\n        constructor(template, options = {}) {\n            if (!template) {\n                throw new Error('Order template is required');\n            }\n            \n            this.template = template;\n            this.ingredients = [...template.ingredients];\n            this.currentIndex = 0;\n            this.timeLeft = template.time * 1000; // Convert to milliseconds\n            this.x = 0;\n            this.y = 0;\n            this.width = options.width || 120;\n            this.height = options.height || 180;\n            this.completed = false;\n            this.expired = false;\n            \n            // Animation properties\n            this.animationTime = 0;\n            this.pulsePhase = Math.random() * Math.PI * 2; // Random phase for pulsing\n            \n            // Rendering options\n            this.enableTextures = options.enableTextures !== false;\n            this.enableShadows = options.enableShadows !== false;\n            this.enablePulse = options.enablePulse !== false;\n        }\n\n        /**\n         * Update order state\n         * @param {number} deltaTime - Time elapsed since last frame in seconds\n         * @param {object} gameState - Game state for power-up checks\n         * @returns {boolean} True if order is still valid, false if expired\n         */\n        update(deltaTime, gameState) {\n            this.animationTime += deltaTime;\n            \n            // Apply time freeze power-up if available\n            let shouldDecrementTime = true;\n            if (gameState && gameState.isPowerUpActive && gameState.isPowerUpActive('timeFreeze')) {\n                shouldDecrementTime = false;\n            }\n            \n            if (shouldDecrementTime && !this.completed) {\n                this.timeLeft -= deltaTime * 1000; // Convert to milliseconds\n            }\n            \n            if (this.timeLeft <= 0 && !this.completed) {\n                this.expired = true;\n                return false; // Order expired\n            }\n            \n            return true;\n        }\n\n        /**\n         * Render the order\n         * @param {CanvasRenderingContext2D} ctx - Canvas rendering context\n         * @param {number} index - Order position index for layout\n         * @param {number} frameCount - Current frame count for animations\n         * @param {object} options - Additional rendering options\n         */\n        draw(ctx, index, frameCount, options = {}) {\n            const margin = options.margin || 10;\n            this.x = margin + index * (this.width + margin);\n            this.y = options.startY || 80;\n\n            const isExpiring = this.timeLeft < 10000; // Less than 10 seconds\n            \n            ctx.save();\n            \n            // Background with texture if available\n            if (this.enableTextures && options.textures?.paper) {\n                ctx.fillStyle = options.textures.paper;\n                ctx.fillRect(this.x, this.y, this.width, this.height);\n            }\n            \n            // Add gradient overlay\n            const gradient = ctx.createLinearGradient(this.x, this.y, this.x, this.y + this.height);\n            \n            if (isExpiring) {\n                gradient.addColorStop(0, 'rgba(255, 120, 120, 0.85)');\n                gradient.addColorStop(1, 'rgba(255, 80, 80, 0.8)');\n            } else {\n                gradient.addColorStop(0, 'rgba(255, 255, 255, 0.85)');\n                gradient.addColorStop(1, 'rgba(245, 245, 245, 0.8)');\n            }\n            \n            // Add shadow if enabled\n            if (this.enableShadows) {\n                ctx.shadowColor = 'rgba(0, 0, 0, 0.3)';\n                ctx.shadowBlur = 10;\n                ctx.shadowOffsetX = 3;\n                ctx.shadowOffsetY = 4;\n            }\n            \n            ctx.fillStyle = gradient;\n            ctx.fillRect(this.x, this.y, this.width, this.height);\n            \n            // Reset shadow for border\n            if (this.enableShadows) {\n                ctx.shadowColor = 'transparent';\n            }\n            \n            // Border\n            ctx.strokeStyle = isExpiring ? '#CC3333' : '#333';\n            ctx.lineWidth = 2;\n            ctx.strokeRect(this.x, this.y, this.width, this.height);\n            \n            ctx.restore();\n\n            // Order name with better typography\n            ctx.fillStyle = '#333';\n            ctx.font = '600 12px Nunito, Arial';\n            ctx.textAlign = 'center';\n            ctx.fillText(this.template.name, this.x + this.width / 2, this.y + 15);\n\n            // Timer with enhanced typography\n            const timeSeconds = Math.ceil(this.timeLeft / 1000);\n            ctx.fillStyle = this.timeLeft < 10000 ? '#FF0000' : '#333';\n            ctx.font = '700 14px Nunito, Arial';\n            ctx.fillText(`${timeSeconds}s`, this.x + this.width / 2, this.y + 30);\n\n            // Ingredients (from bottom to top)\n            this.drawIngredients(ctx, frameCount);\n        }\n        \n        /**\n         * Draw the ingredient list for the order\n         * @param {CanvasRenderingContext2D} ctx - Canvas rendering context\n         * @param {number} frameCount - Current frame count for animations\n         */\n        drawIngredients(ctx, frameCount) {\n            const startY = this.y + this.height - 25;\n            const spacing = 20;\n            \n            for (let i = 0; i < this.ingredients.length; i++) {\n                const ingredient = ingredientTypes[this.ingredients[i]];\n                if (!ingredient) continue;\n                \n                const yPos = startY - (i * spacing);\n                \n                ctx.save();\n                \n                if (i < this.currentIndex) {\n                    ctx.globalAlpha = 0.3; // Completed ingredients\n                } else if (i === this.currentIndex) {\n                    // Enhanced highlight for current ingredient\n                    this.drawCurrentIngredientHighlight(ctx, yPos, frameCount);\n                }\n                \n                // Draw ingredient emoji\n                if (i === this.currentIndex) {\n                    this.drawCurrentIngredient(ctx, ingredient, yPos);\n                } else {\n                    this.drawIngredient(ctx, ingredient, yPos);\n                }\n                \n                ctx.restore();\n            }\n        }\n        \n        /**\n         * Draw highlight for the current ingredient\n         * @param {CanvasRenderingContext2D} ctx - Canvas rendering context\n         * @param {number} yPos - Y position for the ingredient\n         * @param {number} frameCount - Current frame count for animations\n         */\n        drawCurrentIngredientHighlight(ctx, yPos, frameCount) {\n            const highlightGradient = ctx.createLinearGradient(\n                this.x + 5, yPos - 15, \n                this.x + this.width - 5, yPos + 10\n            );\n            highlightGradient.addColorStop(0, 'rgba(255, 255, 255, 0.8)');\n            highlightGradient.addColorStop(0.5, 'rgba(255, 215, 0, 0.9)');\n            highlightGradient.addColorStop(1, 'rgba(255, 165, 0, 0.7)');\n            \n            ctx.fillStyle = highlightGradient;\n            ctx.fillRect(this.x + 3, yPos - 17, this.width - 6, 29);\n            \n            // Add border for better visibility\n            ctx.strokeStyle = '#FF8C00';\n            ctx.lineWidth = 2;\n            ctx.strokeRect(this.x + 3, yPos - 17, this.width - 6, 29);\n            \n            // Add pulsing effect if enabled\n            if (this.enablePulse) {\n                const pulseAlpha = 0.3 + Math.sin(frameCount * 0.15 + this.pulsePhase) * 0.2;\n                ctx.fillStyle = `rgba(255, 215, 0, ${pulseAlpha})`;\n                ctx.fillRect(this.x + 1, yPos - 19, this.width - 2, 33);\n            }\n        }\n        \n        /**\n         * Draw the current (highlighted) ingredient\n         * @param {CanvasRenderingContext2D} ctx - Canvas rendering context\n         * @param {object} ingredient - Ingredient data\n         * @param {number} yPos - Y position for the ingredient\n         */\n        drawCurrentIngredient(ctx, ingredient, yPos) {\n            ctx.font = '20px Arial'; // Keep Arial for emoji compatibility\n            ctx.textAlign = 'center';\n            \n            // Enhanced glow and contrast for current ingredient\n            ctx.shadowColor = '#FF4500';\n            ctx.shadowBlur = 12;\n            ctx.shadowOffsetX = 0;\n            ctx.shadowOffsetY = 0;\n            \n            // Add white outline for better contrast\n            ctx.strokeStyle = '#FFFFFF';\n            ctx.lineWidth = 3;\n            ctx.strokeText(ingredient.emoji, this.x + this.width / 2, yPos);\n            \n            // Scale up the current ingredient slightly\n            ctx.save();\n            ctx.translate(this.x + this.width / 2, yPos);\n            ctx.scale(1.2, 1.2);\n            ctx.fillText(ingredient.emoji, 0, 0);\n            ctx.restore();\n            \n            // Reset shadow\n            ctx.shadowColor = 'transparent';\n            ctx.shadowBlur = 0;\n            ctx.shadowOffsetX = 0;\n            ctx.shadowOffsetY = 0;\n        }\n        \n        /**\n         * Draw a regular ingredient\n         * @param {CanvasRenderingContext2D} ctx - Canvas rendering context\n         * @param {object} ingredient - Ingredient data\n         * @param {number} yPos - Y position for the ingredient\n         */\n        drawIngredient(ctx, ingredient, yPos) {\n            ctx.font = '20px Arial';\n            ctx.textAlign = 'center';\n            ctx.fillText(ingredient.emoji, this.x + this.width / 2, yPos);\n        }\n\n        /**\n         * Check if an ingredient matches the current expected ingredient\n         * @param {string} type - Ingredient type to check\n         * @returns {string} 'correct', 'completed', or 'wrong'\n         */\n        checkIngredient(type) {\n            if (this.completed || this.expired) {\n                return 'wrong';\n            }\n            \n            if (this.currentIndex < this.ingredients.length && \n                this.ingredients[this.currentIndex] === type) {\n                this.currentIndex++;\n                \n                if (this.currentIndex >= this.ingredients.length) {\n                    this.completed = true;\n                    return 'completed';\n                }\n                \n                return 'correct';\n            }\n            \n            return 'wrong';\n        }\n        \n        /**\n         * Get the current expected ingredient type\n         * @returns {string|null} Current ingredient type or null if order is complete\n         */\n        getCurrentIngredient() {\n            if (this.currentIndex >= this.ingredients.length) {\n                return null;\n            }\n            return this.ingredients[this.currentIndex];\n        }\n        \n        /**\n         * Get order completion progress\n         * @returns {number} Progress as a value between 0 and 1\n         */\n        getProgress() {\n            return this.currentIndex / this.ingredients.length;\n        }\n        \n        /**\n         * Get remaining time in seconds\n         * @returns {number} Time remaining in seconds\n         */\n        getTimeRemaining() {\n            return Math.max(0, this.timeLeft / 1000);\n        }\n        \n        /**\n         * Check if order is completed\n         * @returns {boolean} True if completed\n         */\n        isCompleted() {\n            return this.completed;\n        }\n        \n        /**\n         * Check if order has expired\n         * @returns {boolean} True if expired\n         */\n        isExpired() {\n            return this.expired;\n        }\n        \n        /**\n         * Check if order is expiring soon (less than 10 seconds)\n         * @returns {boolean} True if expiring soon\n         */\n        isExpiringSoon() {\n            return this.timeLeft < 10000;\n        }\n        \n        /**\n         * Get order bounds for UI layout\n         * @returns {object} Bounds object {x, y, width, height}\n         */\n        getBounds() {\n            return {\n                x: this.x,\n                y: this.y,\n                width: this.width,\n                height: this.height\n            };\n        }\n        \n        /**\n         * Reset order to initial state\n         */\n        reset() {\n            this.currentIndex = 0;\n            this.timeLeft = this.template.time * 1000;\n            this.completed = false;\n            this.expired = false;\n            this.animationTime = 0;\n        }\n        \n        /**\n         * Create a random order from available templates\n         * @param {object} options - Options for order creation\n         * @returns {Order} New random order\n         */\n        static createRandom(options = {}) {\n            const template = orderTemplates[Math.floor(Math.random() * orderTemplates.length)];\n            return new Order(template, options);\n        }\n        \n        /**\n         * Get all available order templates\n         * @returns {Array<object>} Array of order templates\n         */\n        static getAvailableTemplates() {\n            return [...orderTemplates];\n        }\n        \n        /**\n         * Get a specific order template by name\n         * @param {string} name - Template name\n         * @returns {object|null} Template or null if not found\n         */\n        static getTemplateByName(name) {\n            return orderTemplates.find(template => template.name === name) || null;\n        }\n        \n        /**\n         * Validate order template\n         * @param {object} template - Template to validate\n         * @returns {boolean} True if valid template\n         */\n        static isValidTemplate(template) {\n            return !!(template && \n                   typeof template.name === 'string' &&\n                   Array.isArray(template.ingredients) &&\n                   template.ingredients.length > 0 &&\n                   typeof template.time === 'number' &&\n                   template.time > 0);\n        }\n    }\n\n    /**\n     * Audio System\n     * \n     * Complete Web Audio API-based audio system with procedural sound generation,\n     * background music, volume controls, and audio ducking.\n     */\n\n    /**\n     * Sound effect definitions\n     */\n    const soundEffects = {\n        ingredientCorrect: {\n            frequency: 880,\n            type: 'sine',\n            duration: 0.15,\n            volume: 0.6\n        },\n        ingredientWrong: {\n            frequency: 220,\n            type: 'sawtooth',\n            duration: 0.2,\n            volume: 0.5\n        },\n        orderComplete: {\n            frequencies: [523, 659, 784, 1047], // C, E, G, High C\n            type: 'sine',\n            duration: 0.2,\n            volume: 0.8\n        },\n        orderExpired: {\n            frequency: 165,\n            type: 'square',\n            duration: 0.3,\n            volume: 0.7\n        },\n        powerUpCollect: {\n            frequency: 698,\n            type: 'triangle',\n            duration: 0.25,\n            volume: 0.7\n        },\n        doublePointsActivate: {\n            frequency: 1397, // F6\n            type: 'sine',\n            duration: 0.3,\n            volume: 0.8,\n            duck: true\n        },\n        slowTimeActivate: {\n            frequency: 440, // A4\n            type: 'triangle',\n            duration: 0.4,\n            volume: 0.8,\n            duck: true\n        },\n        comboMultiplierActivate: {\n            frequency: 587, // D5\n            type: 'square',\n            duration: 0.35,\n            volume: 0.7,\n            duck: true\n        },\n        comboIncrease: {\n            frequency: 659, // E5\n            type: 'sine',\n            duration: 0.1,\n            volume: 0.5\n        },\n        buttonClick: {\n            frequency: 1000,\n            type: 'sine',\n            duration: 0.05,\n            volume: 0.3\n        },\n        gameOver: {\n            frequencies: [330, 311, 294, 277], // E, Eb, D, Db\n            type: 'sawtooth',\n            duration: 0.4,\n            volume: 0.8\n        }\n    };\n\n    /**\n     * Music note definitions\n     */\n    const musicNotes = {\n        melody: [523, 587, 659, 784, 880]};\n\n    class AudioSystem {\n        constructor(options = {}) {\n            // Audio context and processing chain\n            this.audioContext = null;\n            this.audioProcessingChain = null;\n            this.enabled = true;\n            \n            // Audio settings\n            this.settings = {\n                master: options.master || 0.3,\n                effects: options.effects || 1.0,\n                music: options.music || 0.5,\n                preset: options.preset || 'normal'\n            };\n            \n            // Background music state\n            this.backgroundMusic = {\n                playing: false,\n                oscillators: [],\n                gainNodes: [],\n                melodyInterval: null,\n                cleanupInterval: null\n            };\n            \n            // Audio ducking\n            this.musicGainNode = null;\n            this.isDucking = false;\n            \n            // Event listeners\n            this.eventListeners = new Map();\n            \n            // Initialize audio system\n            this.init();\n        }\n        \n        /**\n         * Initialize the audio system\n         */\n        init() {\n            try {\n                this.audioContext = new (window.AudioContext || window.webkitAudioContext)();\n                this.setupAudioProcessingChain();\n                this.setupUserInteractionHandlers();\n            } catch (e) {\n                console.warn('Web Audio API not supported');\n                this.enabled = false;\n            }\n        }\n        \n        /**\n         * Set up audio processing chain with compressor and limiter\n         */\n        setupAudioProcessingChain() {\n            if (!this.audioContext) return;\n            \n            // Create compressor\n            const compressor = this.audioContext.createDynamicsCompressor();\n            compressor.threshold.setValueAtTime(-20, this.audioContext.currentTime);\n            compressor.knee.setValueAtTime(10, this.audioContext.currentTime);\n            compressor.ratio.setValueAtTime(6, this.audioContext.currentTime);\n            compressor.attack.setValueAtTime(0.003, this.audioContext.currentTime);\n            compressor.release.setValueAtTime(0.1, this.audioContext.currentTime);\n            \n            // Create limiter\n            const limiter = this.audioContext.createDynamicsCompressor();\n            limiter.threshold.setValueAtTime(-6, this.audioContext.currentTime);\n            limiter.knee.setValueAtTime(0, this.audioContext.currentTime);\n            limiter.ratio.setValueAtTime(20, this.audioContext.currentTime);\n            limiter.attack.setValueAtTime(0.001, this.audioContext.currentTime);\n            limiter.release.setValueAtTime(0.01, this.audioContext.currentTime);\n            \n            // Chain: compressor -> limiter -> destination\n            compressor.connect(limiter);\n            limiter.connect(this.audioContext.destination);\n            \n            this.audioProcessingChain = compressor;\n        }\n        \n        /**\n         * Set up user interaction handlers for audio context resume\n         */\n        setupUserInteractionHandlers() {\n            const resumeAudio = () => {\n                if (this.audioContext && this.audioContext.state === 'suspended') {\n                    this.audioContext.resume();\n                }\n            };\n            \n            document.addEventListener('click', resumeAudio, { once: true });\n            document.addEventListener('touchstart', resumeAudio, { once: true });\n        }\n        \n        /**\n         * Create an oscillator with the audio processing chain\n         */\n        createOscillator(frequency, type = 'sine', duration = 0.1, volumeMultiplier = 1) {\n            if (!this.audioContext || !this.enabled) return null;\n            \n            const oscillator = this.audioContext.createOscillator();\n            const gainNode = this.audioContext.createGain();\n            \n            // Add low-pass filter to smooth harsh frequencies\n            const filter = this.audioContext.createBiquadFilter();\n            filter.type = 'lowpass';\n            filter.frequency.setValueAtTime(8000, this.audioContext.currentTime);\n            filter.Q.setValueAtTime(0.7, this.audioContext.currentTime);\n            \n            // Connect audio chain\n            oscillator.connect(gainNode);\n            gainNode.connect(filter);\n            \n            if (this.audioProcessingChain) {\n                filter.connect(this.audioProcessingChain);\n            } else {\n                filter.connect(this.audioContext.destination);\n            }\n            \n            // Configure oscillator\n            oscillator.type = type;\n            oscillator.frequency.setValueAtTime(frequency, this.audioContext.currentTime);\n            \n            // Calculate final volume\n            const finalVolume = this.settings.master * this.settings.effects * volumeMultiplier;\n            \n            // Smooth volume envelope\n            gainNode.gain.setValueAtTime(0, this.audioContext.currentTime);\n            gainNode.gain.linearRampToValueAtTime(finalVolume, this.audioContext.currentTime + 0.01);\n            gainNode.gain.exponentialRampToValueAtTime(0.001, this.audioContext.currentTime + duration);\n            \n            return { oscillator, gainNode, filter };\n        }\n        \n        /**\n         * Play a sound effect\n         */\n        playSound(soundConfig) {\n            if (!this.audioContext || !this.enabled || this.settings.effects === 0) return;\n            \n            const { frequency, type = 'sine', duration = 0.1, volume = 1, duck = false } = soundConfig;\n            const result = this.createOscillator(frequency, type, duration, volume);\n            \n            if (result) {\n                const { oscillator } = result;\n                oscillator.start();\n                oscillator.stop(this.audioContext.currentTime + duration);\n                \n                // Clean up after sound finishes\n                oscillator.addEventListener('ended', () => {\n                    oscillator.disconnect();\n                });\n                \n                // Handle audio ducking\n                if (duck) {\n                    this.duckBackgroundMusic();\n                    setTimeout(() => this.restoreBackgroundMusic(), duration * 1000);\n                }\n            }\n        }\n        \n        /**\n         * Play a sequence of sounds\n         */\n        playSequence(frequencies, type = 'sine', duration = 0.1, volume = 1) {\n            if (!this.audioContext || !this.enabled || this.settings.effects === 0) return;\n            \n            frequencies.forEach((freq, index) => {\n                setTimeout(() => {\n                    this.playSound({ frequency: freq, type, duration: duration * 0.8, volume });\n                }, index * duration * 1000 * 0.9);\n            });\n        }\n        \n        /**\n         * Play specific game sound effects\n         */\n        playIngredientCorrect() {\n            this.playSound(soundEffects.ingredientCorrect);\n        }\n        \n        playIngredientWrong() {\n            this.playSound(soundEffects.ingredientWrong);\n        }\n        \n        playOrderComplete() {\n            this.playSequence(\n                soundEffects.orderComplete.frequencies,\n                soundEffects.orderComplete.type,\n                soundEffects.orderComplete.duration,\n                soundEffects.orderComplete.volume\n            );\n        }\n        \n        playOrderExpired() {\n            this.playSound(soundEffects.orderExpired);\n        }\n        \n        playPowerUpCollect() {\n            this.playSound(soundEffects.powerUpCollect);\n        }\n        \n        playPowerUpActivate(type) {\n            const soundKey = type + 'Activate';\n            const sound = soundEffects[soundKey];\n            if (sound) {\n                this.duckBackgroundMusic();\n                this.playSound(sound);\n                setTimeout(() => this.restoreBackgroundMusic(), 300);\n            }\n        }\n        \n        playComboIncrease() {\n            this.playSound(soundEffects.comboIncrease);\n        }\n        \n        playButtonClick() {\n            this.playSound(soundEffects.buttonClick);\n        }\n        \n        playGameOver() {\n            if (!this.audioContext || !this.enabled || this.settings.effects === 0) return;\n            \n            soundEffects.gameOver.frequencies.forEach((freq, index) => {\n                setTimeout(() => {\n                    this.playSound({\n                        frequency: freq,\n                        type: soundEffects.gameOver.type,\n                        duration: soundEffects.gameOver.duration * 0.7,\n                        volume: soundEffects.gameOver.volume\n                    });\n                }, index * 150);\n            });\n        }\n        \n        /**\n         * Alias methods for backward compatibility\n         */\n        playCollect() {\n            this.playIngredientCorrect();\n        }\n        \n        playError() {\n            this.playIngredientWrong();\n        }\n        \n        playNewOrder() {\n            this.playButtonClick();\n        }\n        \n        /**\n         * Start background music\n         */\n        startBackgroundMusic() {\n            if (!this.audioContext || !this.enabled || this.backgroundMusic.playing || this.settings.music === 0) {\n                return;\n            }\n            \n            // Create master gain node for music\n            if (!this.musicGainNode) {\n                this.musicGainNode = this.audioContext.createGain();\n                \n                if (this.audioProcessingChain) {\n                    this.musicGainNode.connect(this.audioProcessingChain);\n                } else {\n                    this.musicGainNode.connect(this.audioContext.destination);\n                }\n                \n                this.musicGainNode.gain.setValueAtTime(\n                    this.settings.master * this.settings.music,\n                    this.audioContext.currentTime\n                );\n            }\n            \n            this.backgroundMusic.playing = true;\n            \n            // Start melody interval\n            this.backgroundMusic.melodyInterval = setInterval(() => {\n                if (this.backgroundMusic.playing && this.settings.music > 0) {\n                    this.playMelodyNote();\n                } else {\n                    clearInterval(this.backgroundMusic.melodyInterval);\n                }\n            }, 3000 + Math.random() * 2000);\n            \n            // Start cleanup interval\n            this.backgroundMusic.cleanupInterval = setInterval(() => {\n                this.cleanupOscillators();\n            }, 5000);\n        }\n        \n        /**\n         * Stop background music\n         */\n        stopBackgroundMusic() {\n            this.backgroundMusic.playing = false;\n            \n            // Clear intervals\n            if (this.backgroundMusic.melodyInterval) {\n                clearInterval(this.backgroundMusic.melodyInterval);\n                this.backgroundMusic.melodyInterval = null;\n            }\n            if (this.backgroundMusic.cleanupInterval) {\n                clearInterval(this.backgroundMusic.cleanupInterval);\n                this.backgroundMusic.cleanupInterval = null;\n            }\n            \n            // Stop all oscillators\n            this.backgroundMusic.oscillators.forEach(osc => {\n                try {\n                    osc.stop();\n                    osc.disconnect();\n                } catch (e) {\n                    // Oscillator might already be stopped\n                }\n            });\n            \n            this.backgroundMusic.oscillators = [];\n            this.backgroundMusic.gainNodes = [];\n        }\n        \n        /**\n         * Play a single melody note\n         */\n        playMelodyNote() {\n            if (!this.backgroundMusic.playing || !this.musicGainNode || this.settings.music === 0) {\n                return;\n            }\n            \n            const noteIndex = Math.floor(Math.random() * musicNotes.melody.length);\n            const frequency = musicNotes.melody[noteIndex];\n            const musicVolume = this.settings.master * this.settings.music * 0.1;\n            \n            const melodyOsc = this.audioContext.createOscillator();\n            const melodyGain = this.audioContext.createGain();\n            \n            melodyOsc.connect(melodyGain);\n            melodyGain.connect(this.musicGainNode);\n            \n            melodyOsc.type = 'sine';\n            melodyOsc.frequency.setValueAtTime(frequency, this.audioContext.currentTime);\n            \n            melodyGain.gain.setValueAtTime(0, this.audioContext.currentTime);\n            melodyGain.gain.linearRampToValueAtTime(musicVolume, this.audioContext.currentTime + 0.1);\n            melodyGain.gain.exponentialRampToValueAtTime(0.001, this.audioContext.currentTime + 1.5);\n            \n            melodyOsc.start();\n            melodyOsc.stop(this.audioContext.currentTime + 2);\n            \n            // Cleanup after note finishes\n            melodyOsc.addEventListener('ended', () => {\n                const oscIndex = this.backgroundMusic.oscillators.indexOf(melodyOsc);\n                const gainIndex = this.backgroundMusic.gainNodes.indexOf(melodyGain);\n                if (oscIndex > -1) this.backgroundMusic.oscillators.splice(oscIndex, 1);\n                if (gainIndex > -1) this.backgroundMusic.gainNodes.splice(gainIndex, 1);\n            });\n            \n            this.backgroundMusic.oscillators.push(melodyOsc);\n            this.backgroundMusic.gainNodes.push(melodyGain);\n        }\n        \n        /**\n         * Clean up ended oscillators\n         */\n        cleanupOscillators() {\n            this.backgroundMusic.oscillators = this.backgroundMusic.oscillators.filter(osc => {\n                try {\n                    return osc.context.state !== 'closed';\n                } catch (e) {\n                    return false;\n                }\n            });\n            \n            this.backgroundMusic.gainNodes = this.backgroundMusic.gainNodes.filter(gain => {\n                try {\n                    return gain.context.state !== 'closed';\n                } catch (e) {\n                    return false;\n                }\n            });\n        }\n        \n        /**\n         * Duck background music volume\n         */\n        duckBackgroundMusic() {\n            if (!this.musicGainNode || this.isDucking) return;\n            \n            this.isDucking = true;\n            const currentVolume = this.settings.master * this.settings.music;\n            const duckedVolume = currentVolume * 0.3;\n            \n            this.musicGainNode.gain.cancelScheduledValues(this.audioContext.currentTime);\n            this.musicGainNode.gain.setValueAtTime(currentVolume, this.audioContext.currentTime);\n            this.musicGainNode.gain.linearRampToValueAtTime(duckedVolume, this.audioContext.currentTime + 0.1);\n        }\n        \n        /**\n         * Restore background music volume\n         */\n        restoreBackgroundMusic() {\n            if (!this.musicGainNode || !this.isDucking) return;\n            \n            this.isDucking = false;\n            const normalVolume = this.settings.master * this.settings.music;\n            \n            this.musicGainNode.gain.cancelScheduledValues(this.audioContext.currentTime);\n            this.musicGainNode.gain.linearRampToValueAtTime(normalVolume, this.audioContext.currentTime + 0.3);\n        }\n        \n        /**\n         * Update master volume\n         */\n        setMasterVolume(value) {\n            this.settings.master = Math.max(0, Math.min(1, value));\n            \n            if (this.musicGainNode && !this.isDucking) {\n                const musicVolume = this.settings.master * this.settings.music;\n                this.musicGainNode.gain.setValueAtTime(musicVolume, this.audioContext.currentTime);\n            }\n            \n            this.emit('volumeChanged', { type: 'master', value: this.settings.master });\n        }\n        \n        /**\n         * Update effects volume\n         */\n        setEffectsVolume(value) {\n            this.settings.effects = Math.max(0, Math.min(1, value));\n            this.emit('volumeChanged', { type: 'effects', value: this.settings.effects });\n        }\n        \n        /**\n         * Update music volume\n         */\n        setMusicVolume(value) {\n            this.settings.music = Math.max(0, Math.min(1, value));\n            \n            if (this.musicGainNode && !this.isDucking) {\n                const musicVolume = this.settings.master * this.settings.music;\n                this.musicGainNode.gain.setValueAtTime(musicVolume, this.audioContext.currentTime);\n            }\n            \n            // Handle music start/stop based on volume\n            if (value > 0 && !this.backgroundMusic.playing) {\n                this.startBackgroundMusic();\n            } else if (value === 0) {\n                this.stopBackgroundMusic();\n            }\n            \n            this.emit('volumeChanged', { type: 'music', value: this.settings.music });\n        }\n        \n        /**\n         * Set audio preset\n         */\n        setPreset(preset) {\n            const presets = {\n                quiet: { master: 0.15, effects: 0.8, music: 0.3 },\n                normal: { master: 0.3, effects: 1.0, music: 0.5 },\n                energetic: { master: 0.5, effects: 1.0, music: 0.7 }\n            };\n            \n            const config = presets[preset];\n            if (config) {\n                this.setMasterVolume(config.master);\n                this.setEffectsVolume(config.effects);\n                this.setMusicVolume(config.music);\n                this.settings.preset = preset;\n                this.emit('presetChanged', preset);\n            }\n        }\n        \n        /**\n         * Enable/disable audio system\n         */\n        setEnabled(enabled) {\n            this.enabled = enabled;\n            \n            if (!enabled) {\n                this.stopBackgroundMusic();\n            }\n            \n            this.emit('enabledChanged', enabled);\n        }\n        \n        /**\n         * Get current audio settings\n         */\n        getSettings() {\n            return { ...this.settings };\n        }\n        \n        /**\n         * Check if audio is enabled and supported\n         */\n        isEnabled() {\n            return this.enabled && !!this.audioContext;\n        }\n        \n        /**\n         * Cleanup audio system\n         */\n        destroy() {\n            this.stopBackgroundMusic();\n            \n            if (this.musicGainNode) {\n                this.musicGainNode.disconnect();\n                this.musicGainNode = null;\n            }\n            \n            if (this.audioContext) {\n                this.audioContext.close();\n                this.audioContext = null;\n            }\n            \n            this.eventListeners.clear();\n        }\n        \n        /**\n         * Event system for audio callbacks\n         */\n        on(event, callback) {\n            if (!this.eventListeners.has(event)) {\n                this.eventListeners.set(event, []);\n            }\n            this.eventListeners.get(event).push(callback);\n        }\n        \n        off(event, callback) {\n            const callbacks = this.eventListeners.get(event);\n            if (callbacks) {\n                const index = callbacks.indexOf(callback);\n                if (index > -1) {\n                    callbacks.splice(index, 1);\n                }\n            }\n        }\n        \n        emit(event, data) {\n            const callbacks = this.eventListeners.get(event);\n            if (callbacks) {\n                callbacks.forEach(callback => {\n                    try {\n                        callback(data);\n                    } catch (error) {\n                        console.error(`Error in audio event listener for ${event}:`, error);\n                    }\n                });\n            }\n        }\n    }\n\n    /**\n     * Color Theme System\n     * \n     * Dynamic color management with theme transitions and texture pattern generation.\n     * Colors respond to game state (combo level and score) for enhanced visual feedback.\n     */\n\n\n    /**\n     * Create texture patterns for visual enhancement\n     * @param {CanvasRenderingContext2D} ctx - Canvas context for pattern creation\n     * @param {string} type - Type of texture ('wood', 'marble', 'fabric', 'paper')\n     * @param {number} size - Size of the pattern (default: 50)\n     * @returns {CanvasPattern} Canvas pattern object\n     */\n    function createTexturePattern(ctx, type, size = 50) {\n        const patternCanvas = document.createElement('canvas');\n        patternCanvas.width = size;\n        patternCanvas.height = size;\n        const patternCtx = patternCanvas.getContext('2d');\n        \n        switch(type) {\n            case 'wood':\n                // Wood grain texture\n                const woodGradient = patternCtx.createLinearGradient(0, 0, 0, size);\n                woodGradient.addColorStop(0, '#DEB887');\n                woodGradient.addColorStop(0.3, '#D2B48C');\n                woodGradient.addColorStop(0.7, '#CD853F');\n                woodGradient.addColorStop(1, '#A0522D');\n                patternCtx.fillStyle = woodGradient;\n                patternCtx.fillRect(0, 0, size, size);\n                \n                // Add wood grain lines\n                patternCtx.strokeStyle = 'rgba(139, 69, 19, 0.3)';\n                patternCtx.lineWidth = 1;\n                for(let i = 0; i < 8; i++) {\n                    const y = (i * size / 8) + Math.sin(i) * 3;\n                    patternCtx.beginPath();\n                    patternCtx.moveTo(0, y);\n                    patternCtx.lineTo(size, y + Math.sin(i * 0.5) * 2);\n                    patternCtx.stroke();\n                }\n                break;\n                \n            case 'marble':\n                // Marble texture\n                const marbleGradient = patternCtx.createRadialGradient(size/2, size/2, 0, size/2, size/2, size/2);\n                marbleGradient.addColorStop(0, '#F8F8FF');\n                marbleGradient.addColorStop(0.5, '#E6E6FA');\n                marbleGradient.addColorStop(1, '#D3D3D3');\n                patternCtx.fillStyle = marbleGradient;\n                patternCtx.fillRect(0, 0, size, size);\n                \n                // Add marble veins\n                patternCtx.strokeStyle = 'rgba(169, 169, 169, 0.4)';\n                patternCtx.lineWidth = 2;\n                patternCtx.beginPath();\n                patternCtx.moveTo(0, size * 0.3);\n                patternCtx.quadraticCurveTo(size * 0.7, size * 0.1, size, size * 0.8);\n                patternCtx.stroke();\n                break;\n                \n            case 'fabric':\n                // Fabric weave texture\n                patternCtx.fillStyle = '#F5F5DC';\n                patternCtx.fillRect(0, 0, size, size);\n                \n                patternCtx.fillStyle = 'rgba(210, 180, 140, 0.5)';\n                const gridSize = size / 10;\n                for(let x = 0; x < size; x += gridSize) {\n                    for(let y = 0; y < size; y += gridSize) {\n                        if((Math.floor(x/gridSize) + Math.floor(y/gridSize)) % 2) {\n                            patternCtx.fillRect(x, y, gridSize, gridSize);\n                        }\n                    }\n                }\n                break;\n                \n            case 'paper':\n                // Paper texture\n                patternCtx.fillStyle = '#FFFEF0';\n                patternCtx.fillRect(0, 0, size, size);\n                \n                // Add paper fibers\n                for(let i = 0; i < 20; i++) {\n                    patternCtx.strokeStyle = `rgba(220, 220, 200, ${Math.random() * 0.3})`;\n                    patternCtx.lineWidth = 0.5;\n                    patternCtx.beginPath();\n                    patternCtx.moveTo(Math.random() * size, Math.random() * size);\n                    patternCtx.lineTo(Math.random() * size, Math.random() * size);\n                    patternCtx.stroke();\n                }\n                break;\n                \n            default:\n                // Default solid color\n                patternCtx.fillStyle = '#FFFFFF';\n                patternCtx.fillRect(0, 0, size, size);\n                break;\n        }\n        \n        return ctx.createPattern(patternCanvas, 'repeat');\n    }\n\n    /**\n     * Get a random color from a predefined palette\n     * @returns {string} Hex color string\n     */\n    function getRandomColor() {\n        const colors = [\n            '#FF6B6B', // Red\n            '#4ECDC4', // Teal\n            '#45B7D1', // Blue\n            '#F7DC6F', // Yellow\n            '#BB8FCE', // Purple\n            '#85C872', // Green\n            '#F8B500', // Orange\n            '#FF6F91', // Pink\n            '#6C5CE7', // Violet\n            '#00D2D3'  // Cyan\n        ];\n        return colors[Math.floor(Math.random() * colors.length)];\n    }\n\n    /**\n     * Renderer System\n     * \n     * Comprehensive canvas rendering system with texture patterns, screen effects,\n     * custom graphics, and dynamic visual features.\n     */\n\n\n    class Renderer {\n        constructor(canvas, options = {}) {\n            this.canvas = canvas;\n            this.ctx = canvas.getContext('2d');\n            \n            // Rendering options\n            this.enableTextures = options.enableTextures !== false;\n            this.enableShadows = options.enableShadows !== false;\n            this.enableEffects = options.enableEffects !== false;\n            \n            // Canvas patterns\n            this.patterns = {\n                wood: null,\n                marble: null,\n                fabric: null,\n                paper: null\n            };\n            \n            // Screen effects\n            this.screenEffects = {\n                shake: { intensity: 0, duration: 0, x: 0, y: 0 },\n                flash: { intensity: 0, color: '#FFFFFF', duration: 0 },\n                ripple: { active: false, x: 0, y: 0, radius: 0, maxRadius: 0 },\n                glitch: { active: false, intensity: 0, duration: 0 }\n            };\n            \n            // Performance tracking\n            this.stats = {\n                drawCalls: 0,\n                frameTime: 0,\n                lastFrameTime: 0\n            };\n            \n            // Initialize\n            this.init();\n        }\n        \n        /**\n         * Initialize the renderer\n         */\n        init() {\n            this.setupCanvas();\n            if (this.enableTextures) {\n                this.initializePatterns();\n            }\n            this.setupEventListeners();\n        }\n        \n        /**\n         * Set up canvas properties\n         */\n        setupCanvas() {\n            this.ctx.imageSmoothingEnabled = true;\n            this.ctx.imageSmoothingQuality = 'high';\n            this.resizeCanvas();\n        }\n        \n        /**\n         * Resize canvas to fit window\n         */\n        resizeCanvas() {\n            const oldWidth = this.canvas.width;\n            const oldHeight = this.canvas.height;\n            \n            this.canvas.width = Math.min(window.innerWidth, 480);\n            this.canvas.height = window.innerHeight;\n            \n            // Re-setup context properties after resize\n            this.ctx.imageSmoothingEnabled = true;\n            this.ctx.imageSmoothingQuality = 'high';\n            \n            return { \n                changed: oldWidth !== this.canvas.width || oldHeight !== this.canvas.height,\n                width: this.canvas.width,\n                height: this.canvas.height\n            };\n        }\n        \n        /**\n         * Set up event listeners\n         */\n        setupEventListeners() {\n            window.addEventListener('resize', () => this.resizeCanvas());\n        }\n        \n        /**\n         * Initialize texture patterns\n         */\n        initializePatterns() {\n            this.patterns.wood = createTexturePattern(this.ctx, 'wood', 60);\n            this.patterns.marble = createTexturePattern(this.ctx, 'marble', 80);\n            this.patterns.fabric = createTexturePattern(this.ctx, 'fabric', 40);\n            this.patterns.paper = createTexturePattern(this.ctx, 'paper', 100);\n        }\n        \n        /**\n         * Clear the canvas\n         */\n        clear() {\n            this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);\n            this.stats.drawCalls = 0;\n        }\n        \n        /**\n         * Begin frame rendering\n         */\n        beginFrame(currentTime) {\n            this.stats.frameTime = currentTime - this.stats.lastFrameTime;\n            this.stats.lastFrameTime = currentTime;\n            this.clear();\n        }\n        \n        /**\n         * End frame rendering\n         */\n        endFrame() {\n            this.drawScreenEffects();\n        }\n        \n        /**\n         * Draw enhanced kitchen background\n         */\n        drawBackground() {\n            this.ctx.save();\n            \n            // Main game area texture\n            if (this.enableTextures && this.patterns.fabric) {\n                this.ctx.fillStyle = this.patterns.fabric;\n                this.ctx.globalAlpha = 0.05;\n                this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height - 100);\n                this.ctx.globalAlpha = 1;\n            }\n            \n            // Kitchen counter with wood texture\n            if (this.enableTextures && this.patterns.wood) {\n                this.ctx.fillStyle = this.patterns.wood;\n                this.ctx.globalAlpha = 0.6;\n                this.ctx.fillRect(0, this.canvas.height - 100, this.canvas.width, 100);\n                this.ctx.globalAlpha = 1;\n            }\n            \n            // Add gradient overlay for depth\n            const kitchenGradient = this.ctx.createLinearGradient(\n                0, this.canvas.height - 100, \n                0, this.canvas.height\n            );\n            kitchenGradient.addColorStop(0, 'rgba(139, 69, 19, 0.3)');\n            kitchenGradient.addColorStop(0.5, 'rgba(101, 67, 33, 0.4)');\n            kitchenGradient.addColorStop(1, 'rgba(83, 53, 27, 0.5)');\n            this.ctx.fillStyle = kitchenGradient;\n            this.ctx.fillRect(0, this.canvas.height - 100, this.canvas.width, 100);\n            \n            this.ctx.restore();\n            this.stats.drawCalls++;\n        }\n        \n        /**\n         * Draw custom button with 3D effect\n         */\n        drawButton(x, y, width, height, text, isPressed = false) {\n            this.ctx.save();\n            \n            // Button shadow\n            const shadowOffset = isPressed ? 2 : 4;\n            this.ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';\n            this.ctx.fillRect(x + shadowOffset, y + shadowOffset, width, height);\n            \n            // Button body with gradient\n            const gradient = this.ctx.createLinearGradient(x, y, x, y + height);\n            if (isPressed) {\n                gradient.addColorStop(0, '#E6B800');\n                gradient.addColorStop(1, '#FFD700');\n            } else {\n                gradient.addColorStop(0, '#FFD700');\n                gradient.addColorStop(0.5, '#FFA500');\n                gradient.addColorStop(1, '#FF8C00');\n            }\n            \n            this.ctx.fillStyle = gradient;\n            this.ctx.fillRect(x, y, width, height);\n            \n            // Button border\n            this.ctx.strokeStyle = '#B8860B';\n            this.ctx.lineWidth = 2;\n            this.ctx.strokeRect(x, y, width, height);\n            \n            // Button highlight\n            this.ctx.strokeStyle = 'rgba(255, 255, 255, 0.5)';\n            this.ctx.lineWidth = 1;\n            this.ctx.strokeRect(x + 1, y + 1, width - 2, height - 2);\n            \n            // Button text\n            this.ctx.fillStyle = '#333';\n            this.ctx.font = 'bold 16px Arial';\n            this.ctx.textAlign = 'center';\n            this.ctx.textBaseline = 'middle';\n            this.ctx.fillText(text, x + width/2, y + height/2 + (isPressed ? 1 : 0));\n            \n            this.ctx.restore();\n            this.stats.drawCalls++;\n        }\n        \n        /**\n         * Draw custom heart with optional beating animation\n         */\n        drawHeart(x, y, size, color = '#FF0000', beat = false, frameCount = 0) {\n            this.ctx.save();\n            this.ctx.translate(x, y);\n            \n            if (beat) {\n                const scale = 1 + Math.sin(frameCount * 0.3) * 0.1;\n                this.ctx.scale(scale, scale);\n            }\n            \n            this.ctx.fillStyle = color;\n            this.ctx.beginPath();\n            \n            // Heart shape using curves\n            const heartSize = size * 0.5;\n            this.ctx.moveTo(0, heartSize * 0.3);\n            this.ctx.bezierCurveTo(-heartSize, -heartSize * 0.3, -heartSize, heartSize * 0.3, 0, heartSize);\n            this.ctx.bezierCurveTo(heartSize, heartSize * 0.3, heartSize, -heartSize * 0.3, 0, heartSize * 0.3);\n            this.ctx.fill();\n            \n            // Heart highlight\n            this.ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';\n            this.ctx.beginPath();\n            this.ctx.ellipse(-heartSize * 0.3, -heartSize * 0.1, heartSize * 0.2, heartSize * 0.15, 0, 0, Math.PI * 2);\n            this.ctx.fill();\n            \n            this.ctx.restore();\n            this.stats.drawCalls++;\n        }\n        \n        /**\n         * Draw custom star with optional twinkling animation\n         */\n        drawStar(x, y, size, color = '#FFD700', twinkle = false, frameCount = 0) {\n            this.ctx.save();\n            this.ctx.translate(x, y);\n            \n            if (twinkle) {\n                const rotation = frameCount * 0.05;\n                this.ctx.rotate(rotation);\n                const scale = 0.8 + Math.sin(frameCount * 0.2) * 0.3;\n                this.ctx.scale(scale, scale);\n            }\n            \n            this.ctx.fillStyle = color;\n            \n            // 5-pointed star\n            const spikes = 5;\n            const outerRadius = size;\n            const innerRadius = size * 0.4;\n            \n            this.ctx.beginPath();\n            for (let i = 0; i < spikes; i++) {\n                const angle = (i * Math.PI * 2) / spikes - Math.PI / 2;\n                const x1 = Math.cos(angle) * outerRadius;\n                const y1 = Math.sin(angle) * outerRadius;\n                \n                if (i === 0) this.ctx.moveTo(x1, y1);\n                else this.ctx.lineTo(x1, y1);\n                \n                const innerAngle = angle + Math.PI / spikes;\n                const x2 = Math.cos(innerAngle) * innerRadius;\n                const y2 = Math.sin(innerAngle) * innerRadius;\n                this.ctx.lineTo(x2, y2);\n            }\n            this.ctx.closePath();\n            this.ctx.fill();\n            \n            // Star highlight\n            this.ctx.fillStyle = 'rgba(255, 255, 255, 0.4)';\n            this.ctx.beginPath();\n            this.ctx.arc(0, -size * 0.2, size * 0.15, 0, Math.PI * 2);\n            this.ctx.fill();\n            \n            this.ctx.restore();\n            this.stats.drawCalls++;\n        }\n        \n        /**\n         * Draw custom burger illustration\n         */\n        drawBurger(x, y, size) {\n            this.ctx.save();\n            this.ctx.translate(x, y);\n            \n            const layers = [\n                { color: '#D2B48C', height: size * 0.15, type: 'bun' },\n                { color: '#90EE90', height: size * 0.08, type: 'lettuce' },\n                { color: '#FF6347', height: size * 0.08, type: 'tomato' },\n                { color: '#FFD700', height: size * 0.06, type: 'cheese' },\n                { color: '#8B4513', height: size * 0.2, type: 'patty' },\n                { color: '#DEB887', height: size * 0.15, type: 'bun' }\n            ];\n            \n            let currentY = size * 0.4;\n            \n            layers.forEach((layer) => {\n                this.ctx.fillStyle = layer.color;\n                \n                if (layer.type === 'bun') {\n                    // Rounded bun\n                    this.ctx.beginPath();\n                    this.ctx.ellipse(0, currentY, size * 0.4, layer.height, 0, 0, Math.PI * 2);\n                    this.ctx.fill();\n                    \n                    // Bun highlight\n                    this.ctx.fillStyle = 'rgba(255, 255, 255, 0.2)';\n                    this.ctx.beginPath();\n                    this.ctx.ellipse(0, currentY - layer.height * 0.3, size * 0.3, layer.height * 0.5, 0, 0, Math.PI * 2);\n                    this.ctx.fill();\n                } else {\n                    // Flat ingredients\n                    this.ctx.beginPath();\n                    this.ctx.ellipse(0, currentY, size * 0.35, layer.height, 0, 0, Math.PI * 2);\n                    this.ctx.fill();\n                }\n                \n                currentY -= layer.height * 1.5;\n            });\n            \n            this.ctx.restore();\n            this.stats.drawCalls++;\n        }\n        \n        /**\n         * Draw text with enhanced styling\n         */\n        drawText(text, x, y, options = {}) {\n            const {\n                font = '16px Arial',\n                color = '#000000',\n                align = 'left',\n                baseline = 'top',\n                shadow = false,\n                shadowColor = 'rgba(0, 0, 0, 0.5)',\n                shadowBlur = 2,\n                shadowOffset = { x: 1, y: 1 },\n                stroke = false,\n                strokeColor = '#FFFFFF',\n                strokeWidth = 2\n            } = options;\n            \n            this.ctx.save();\n            \n            this.ctx.font = font;\n            this.ctx.textAlign = align;\n            this.ctx.textBaseline = baseline;\n            \n            if (shadow) {\n                this.ctx.shadowColor = shadowColor;\n                this.ctx.shadowBlur = shadowBlur;\n                this.ctx.shadowOffsetX = shadowOffset.x;\n                this.ctx.shadowOffsetY = shadowOffset.y;\n            }\n            \n            if (stroke) {\n                this.ctx.strokeStyle = strokeColor;\n                this.ctx.lineWidth = strokeWidth;\n                this.ctx.strokeText(text, x, y);\n            }\n            \n            this.ctx.fillStyle = color;\n            this.ctx.fillText(text, x, y);\n            \n            this.ctx.restore();\n            this.stats.drawCalls++;\n        }\n        \n        /**\n         * Screen shake effect\n         */\n        startScreenShake(intensity, duration) {\n            this.screenEffects.shake.intensity = intensity;\n            this.screenEffects.shake.duration = duration;\n        }\n        \n        updateScreenShake() {\n            const shake = this.screenEffects.shake;\n            \n            if (shake.duration > 0) {\n                shake.duration--;\n                shake.x = (Math.random() - 0.5) * shake.intensity;\n                shake.y = (Math.random() - 0.5) * shake.intensity;\n                \n                this.canvas.style.transform = `translate(${shake.x}px, ${shake.y}px)`;\n                shake.intensity *= 0.9; // Gradually reduce intensity\n            } else {\n                shake.intensity = 0;\n                shake.x = 0;\n                shake.y = 0;\n                this.canvas.style.transform = 'translate(0px, 0px)';\n            }\n        }\n        \n        /**\n         * Screen flash effect\n         */\n        startScreenFlash(color, intensity, duration) {\n            this.screenEffects.flash.color = color;\n            this.screenEffects.flash.intensity = intensity;\n            this.screenEffects.flash.duration = duration;\n        }\n        \n        updateScreenFlash() {\n            const flash = this.screenEffects.flash;\n            \n            if (flash.duration > 0) {\n                flash.duration--;\n                flash.intensity *= 0.85; // Fade out\n            } else {\n                flash.intensity = 0;\n            }\n        }\n        \n        drawScreenFlash() {\n            const flash = this.screenEffects.flash;\n            \n            if (flash.intensity > 0.01) {\n                this.ctx.save();\n                this.ctx.globalAlpha = flash.intensity;\n                this.ctx.fillStyle = flash.color;\n                this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);\n                this.ctx.restore();\n            }\n        }\n        \n        /**\n         * Ripple effect\n         */\n        startRippleEffect(x, y, maxRadius = 100) {\n            this.screenEffects.ripple.active = true;\n            this.screenEffects.ripple.x = x;\n            this.screenEffects.ripple.y = y;\n            this.screenEffects.ripple.radius = 0;\n            this.screenEffects.ripple.maxRadius = maxRadius;\n        }\n        \n        updateRippleEffect() {\n            const ripple = this.screenEffects.ripple;\n            \n            if (ripple.active) {\n                ripple.radius += 8;\n                if (ripple.radius > ripple.maxRadius) {\n                    ripple.active = false;\n                }\n            }\n        }\n        \n        drawRippleEffect() {\n            const ripple = this.screenEffects.ripple;\n            \n            if (ripple.active) {\n                this.ctx.save();\n                this.ctx.globalAlpha = 0.3 * (1 - ripple.radius / ripple.maxRadius);\n                this.ctx.strokeStyle = '#ffffff';\n                this.ctx.lineWidth = 4;\n                this.ctx.beginPath();\n                this.ctx.arc(ripple.x, ripple.y, ripple.radius, 0, Math.PI * 2);\n                this.ctx.stroke();\n                this.ctx.restore();\n            }\n        }\n        \n        /**\n         * Glitch effect\n         */\n        startGlitchEffect(intensity = 0.1, duration = 10) {\n            this.screenEffects.glitch.active = true;\n            this.screenEffects.glitch.intensity = intensity;\n            this.screenEffects.glitch.duration = duration;\n        }\n        \n        updateGlitchEffect() {\n            const glitch = this.screenEffects.glitch;\n            \n            if (glitch.active) {\n                glitch.duration--;\n                if (glitch.duration <= 0) {\n                    glitch.active = false;\n                }\n            }\n        }\n        \n        drawGlitchEffect() {\n            const glitch = this.screenEffects.glitch;\n            \n            if (glitch.active) {\n                this.ctx.save();\n                this.ctx.globalAlpha = 0.15;\n                this.ctx.fillStyle = Math.random() > 0.5 ? '#ff0000' : '#00ff00';\n                this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);\n                this.ctx.restore();\n            }\n        }\n        \n        /**\n         * Update all screen effects\n         */\n        updateScreenEffects() {\n            this.updateScreenShake();\n            this.updateScreenFlash();\n            this.updateRippleEffect();\n            this.updateGlitchEffect();\n        }\n        \n        /**\n         * Draw all screen effects\n         */\n        drawScreenEffects() {\n            if (!this.enableEffects) return;\n            \n            this.drawScreenFlash();\n            this.drawRippleEffect();\n            this.drawGlitchEffect();\n        }\n        \n        /**\n         * Set up shadows for enhanced 3D effect\n         */\n        setShadow(color = 'rgba(0, 0, 0, 0.1)', blur = 5, offset = { x: 0, y: 2 }) {\n            if (!this.enableShadows) return;\n            \n            this.ctx.shadowColor = color;\n            this.ctx.shadowBlur = blur;\n            this.ctx.shadowOffsetX = offset.x;\n            this.ctx.shadowOffsetY = offset.y;\n        }\n        \n        /**\n         * Clear shadows\n         */\n        clearShadow() {\n            this.ctx.shadowColor = 'transparent';\n            this.ctx.shadowBlur = 0;\n            this.ctx.shadowOffsetX = 0;\n            this.ctx.shadowOffsetY = 0;\n        }\n        \n        /**\n         * Get canvas dimensions\n         */\n        getDimensions() {\n            return {\n                width: this.canvas.width,\n                height: this.canvas.height\n            };\n        }\n        \n        /**\n         * Get rendering statistics\n         */\n        getStats() {\n            return { ...this.stats };\n        }\n        \n        /**\n         * Enable/disable features\n         */\n        setFeature(feature, enabled) {\n            switch (feature) {\n                case 'textures':\n                    this.enableTextures = enabled;\n                    break;\n                case 'shadows':\n                    this.enableShadows = enabled;\n                    break;\n                case 'effects':\n                    this.enableEffects = enabled;\n                    break;\n            }\n        }\n        \n        /**\n         * Get canvas context (for direct drawing when needed)\n         */\n        getContext() {\n            return this.ctx;\n        }\n        \n        /**\n         * Get texture patterns\n         */\n        getPatterns() {\n            return { ...this.patterns };\n        }\n        \n        /**\n         * Create floating text element (DOM-based)\n         */\n        createFloatingText(x, y, text, color = '#FFD700') {\n            const div = document.createElement('div');\n            div.className = 'floating-text';\n            div.style.cssText = `\n            position: absolute;\n            left: ${x}px;\n            top: ${y}px;\n            color: ${color};\n            font-size: 24px;\n            font-weight: bold;\n            pointer-events: none;\n            z-index: 1000;\n            animation: floatUp 1s ease-out forwards;\n        `;\n            div.textContent = text;\n            document.body.appendChild(div);\n            \n            setTimeout(() => div.remove(), 1000);\n        }\n        \n        /**\n         * Cleanup renderer resources\n         */\n        destroy() {\n            window.removeEventListener('resize', this.resizeCanvas);\n            this.patterns = {};\n            this.canvas.style.transform = 'translate(0px, 0px)';\n        }\n    }\n\n    /**\n     * InputSystem - Handles all user input for the game\n     * \n     * Features:\n     * - Unified touch and mouse event handling\n     * - Canvas coordinate transformation\n     * - Mobile-optimized touch handling\n     * - Event delegation for game entities\n     * - Scroll prevention on mobile devices\n     * - Automatic cleanup on destruction\n     */\n    class InputSystem {\n        /**\n         * Creates a new InputSystem instance\n         * @param {HTMLCanvasElement} canvas - The game canvas element\n         * @param {Object} options - Configuration options\n         * @param {boolean} options.preventScroll - Whether to prevent document scrolling on mobile\n         * @param {boolean} options.debug - Enable debug logging\n         */\n        constructor(canvas, options = {}) {\n            this.canvas = canvas;\n            this.options = {\n                preventScroll: true,\n                debug: false,\n                ...options\n            };\n            \n            // Input state\n            this.touches = new Map(); // Track active touches\n            this.mousePosition = { x: 0, y: 0 };\n            this.isMouseDown = false;\n            \n            // Event handlers (bound to preserve context)\n            this.boundHandlers = {\n                handleTouchStart: this.handleTouchStart.bind(this),\n                handleTouchMove: this.handleTouchMove.bind(this),\n                handleTouchEnd: this.handleTouchEnd.bind(this),\n                handleMouseDown: this.handleMouseDown.bind(this),\n                handleMouseMove: this.handleMouseMove.bind(this),\n                handleMouseUp: this.handleMouseUp.bind(this),\n                handleContextMenu: this.handleContextMenu.bind(this),\n                preventScroll: this.preventScroll.bind(this),\n                handleResize: this.handleResize.bind(this)\n            };\n            \n            // Click/tap callbacks\n            this.clickHandlers = [];\n            this.moveHandlers = [];\n            this.resizeHandlers = [];\n            \n            // Canvas bounds cache\n            this.canvasBounds = null;\n            this.updateCanvasBounds();\n            \n            this.setupEventListeners();\n        }\n        \n        /**\n         * Sets up all event listeners\n         * @private\n         */\n        setupEventListeners() {\n            // Touch events\n            this.canvas.addEventListener('touchstart', this.boundHandlers.handleTouchStart, { passive: false });\n            this.canvas.addEventListener('touchmove', this.boundHandlers.handleTouchMove, { passive: false });\n            this.canvas.addEventListener('touchend', this.boundHandlers.handleTouchEnd, { passive: false });\n            this.canvas.addEventListener('touchcancel', this.boundHandlers.handleTouchEnd, { passive: false });\n            \n            // Mouse events\n            this.canvas.addEventListener('mousedown', this.boundHandlers.handleMouseDown);\n            this.canvas.addEventListener('mousemove', this.boundHandlers.handleMouseMove);\n            this.canvas.addEventListener('mouseup', this.boundHandlers.handleMouseUp);\n            this.canvas.addEventListener('mouseleave', this.boundHandlers.handleMouseUp);\n            \n            // Prevent context menu on right-click\n            this.canvas.addEventListener('contextmenu', this.boundHandlers.handleContextMenu);\n            \n            // Prevent scrolling on mobile\n            if (this.options.preventScroll) {\n                document.body.addEventListener('touchmove', this.boundHandlers.preventScroll, { passive: false });\n            }\n            \n            // Window resize\n            window.addEventListener('resize', this.boundHandlers.handleResize);\n            \n            if (this.options.debug) {\n                console.log('InputSystem: Event listeners attached');\n            }\n        }\n        \n        /**\n         * Updates cached canvas bounds\n         * @private\n         */\n        updateCanvasBounds() {\n            this.canvasBounds = this.canvas.getBoundingClientRect();\n        }\n        \n        /**\n         * Converts client coordinates to canvas coordinates\n         * @param {number} clientX - Client X coordinate\n         * @param {number} clientY - Client Y coordinate\n         * @returns {{x: number, y: number}} Canvas coordinates\n         */\n        clientToCanvas(clientX, clientY) {\n            const bounds = this.canvasBounds || this.canvas.getBoundingClientRect();\n            \n            // Account for canvas scaling\n            const scaleX = this.canvas.width / bounds.width;\n            const scaleY = this.canvas.height / bounds.height;\n            \n            return {\n                x: (clientX - bounds.left) * scaleX,\n                y: (clientY - bounds.top) * scaleY\n            };\n        }\n        \n        /**\n         * Handles touch start events\n         * @param {TouchEvent} event - The touch event\n         * @private\n         */\n        handleTouchStart(event) {\n            event.preventDefault();\n            \n            for (const touch of event.changedTouches) {\n                const canvasCoords = this.clientToCanvas(touch.clientX, touch.clientY);\n                \n                this.touches.set(touch.identifier, {\n                    id: touch.identifier,\n                    startX: canvasCoords.x,\n                    startY: canvasCoords.y,\n                    currentX: canvasCoords.x,\n                    currentY: canvasCoords.y,\n                    startTime: Date.now()\n                });\n                \n                // Trigger click handlers for touch start\n                this.triggerClick(canvasCoords.x, canvasCoords.y, 'touch');\n            }\n            \n            if (this.options.debug) {\n                console.log(`InputSystem: ${event.changedTouches.length} touch(es) started`);\n            }\n        }\n        \n        /**\n         * Handles touch move events\n         * @param {TouchEvent} event - The touch event\n         * @private\n         */\n        handleTouchMove(event) {\n            event.preventDefault();\n            \n            for (const touch of event.changedTouches) {\n                const touchData = this.touches.get(touch.identifier);\n                if (touchData) {\n                    const canvasCoords = this.clientToCanvas(touch.clientX, touch.clientY);\n                    touchData.currentX = canvasCoords.x;\n                    touchData.currentY = canvasCoords.y;\n                    \n                    // Trigger move handlers\n                    this.triggerMove(canvasCoords.x, canvasCoords.y, 'touch');\n                }\n            }\n        }\n        \n        /**\n         * Handles touch end events\n         * @param {TouchEvent} event - The touch event\n         * @private\n         */\n        handleTouchEnd(event) {\n            event.preventDefault();\n            \n            for (const touch of event.changedTouches) {\n                this.touches.delete(touch.identifier);\n            }\n            \n            if (this.options.debug) {\n                console.log(`InputSystem: Touch ended, ${this.touches.size} active touches`);\n            }\n        }\n        \n        /**\n         * Handles mouse down events\n         * @param {MouseEvent} event - The mouse event\n         * @private\n         */\n        handleMouseDown(event) {\n            const canvasCoords = this.clientToCanvas(event.clientX, event.clientY);\n            this.isMouseDown = true;\n            this.mousePosition = canvasCoords;\n            \n            // Trigger click handlers for mouse down\n            this.triggerClick(canvasCoords.x, canvasCoords.y, 'mouse');\n            \n            if (this.options.debug) {\n                console.log(`InputSystem: Mouse down at ${canvasCoords.x}, ${canvasCoords.y}`);\n            }\n        }\n        \n        /**\n         * Handles mouse move events\n         * @param {MouseEvent} event - The mouse event\n         * @private\n         */\n        handleMouseMove(event) {\n            const canvasCoords = this.clientToCanvas(event.clientX, event.clientY);\n            this.mousePosition = canvasCoords;\n            \n            if (this.isMouseDown) {\n                this.triggerMove(canvasCoords.x, canvasCoords.y, 'mouse');\n            }\n        }\n        \n        /**\n         * Handles mouse up events\n         * @param {MouseEvent} event - The mouse event\n         * @private\n         */\n        handleMouseUp(event) {\n            this.isMouseDown = false;\n            \n            if (this.options.debug) {\n                console.log('InputSystem: Mouse up');\n            }\n        }\n        \n        /**\n         * Prevents context menu\n         * @param {Event} event - The context menu event\n         * @private\n         */\n        handleContextMenu(event) {\n            event.preventDefault();\n        }\n        \n        /**\n         * Prevents document scrolling\n         * @param {TouchEvent} event - The touch event\n         * @private\n         */\n        preventScroll(event) {\n            if (event.target === this.canvas || this.canvas.contains(event.target)) {\n                event.preventDefault();\n            }\n        }\n        \n        /**\n         * Handles window resize\n         * @param {Event} event - The resize event\n         * @private\n         */\n        handleResize(event) {\n            this.updateCanvasBounds();\n            \n            // Trigger resize handlers\n            for (const handler of this.resizeHandlers) {\n                handler(this.canvas.width, this.canvas.height);\n            }\n            \n            if (this.options.debug) {\n                console.log(`InputSystem: Canvas resized to ${this.canvas.width}x${this.canvas.height}`);\n            }\n        }\n        \n        /**\n         * Triggers click handlers\n         * @param {number} x - Canvas X coordinate\n         * @param {number} y - Canvas Y coordinate\n         * @param {string} type - Input type ('touch' or 'mouse')\n         * @private\n         */\n        triggerClick(x, y, type) {\n            for (const handler of this.clickHandlers) {\n                const handled = handler(x, y, type);\n                if (handled) break; // Stop propagation if handler returns true\n            }\n        }\n        \n        /**\n         * Triggers move handlers\n         * @param {number} x - Canvas X coordinate\n         * @param {number} y - Canvas Y coordinate\n         * @param {string} type - Input type ('touch' or 'mouse')\n         * @private\n         */\n        triggerMove(x, y, type) {\n            for (const handler of this.moveHandlers) {\n                handler(x, y, type);\n            }\n        }\n        \n        /**\n         * Registers a click/tap handler\n         * @param {Function} handler - Handler function (x, y, type) => boolean\n         * @returns {Function} Unregister function\n         */\n        onClick(handler) {\n            this.clickHandlers.push(handler);\n            \n            // Return unregister function\n            return () => {\n                const index = this.clickHandlers.indexOf(handler);\n                if (index !== -1) {\n                    this.clickHandlers.splice(index, 1);\n                }\n            };\n        }\n        \n        /**\n         * Registers a move handler\n         * @param {Function} handler - Handler function (x, y, type) => void\n         * @returns {Function} Unregister function\n         */\n        onMove(handler) {\n            this.moveHandlers.push(handler);\n            \n            // Return unregister function\n            return () => {\n                const index = this.moveHandlers.indexOf(handler);\n                if (index !== -1) {\n                    this.moveHandlers.splice(index, 1);\n                }\n            };\n        }\n        \n        /**\n         * Registers a resize handler\n         * @param {Function} handler - Handler function (width, height) => void\n         * @returns {Function} Unregister function\n         */\n        onResize(handler) {\n            this.resizeHandlers.push(handler);\n            \n            // Return unregister function\n            return () => {\n                const index = this.resizeHandlers.indexOf(handler);\n                if (index !== -1) {\n                    this.resizeHandlers.splice(index, 1);\n                }\n            };\n        }\n        \n        /**\n         * Gets current touch points\n         * @returns {Array} Array of active touch points\n         */\n        getTouches() {\n            return Array.from(this.touches.values());\n        }\n        \n        /**\n         * Gets current mouse position\n         * @returns {{x: number, y: number}} Mouse position in canvas coordinates\n         */\n        getMousePosition() {\n            return { ...this.mousePosition };\n        }\n        \n        /**\n         * Checks if a point is being touched/clicked\n         * @param {number} x - X coordinate to check\n         * @param {number} y - Y coordinate to check\n         * @param {number} radius - Radius around the point to check\n         * @returns {boolean} True if point is being interacted with\n         */\n        isPointActive(x, y, radius = 0) {\n            // Check mouse\n            if (this.isMouseDown) {\n                const dx = this.mousePosition.x - x;\n                const dy = this.mousePosition.y - y;\n                if (Math.sqrt(dx * dx + dy * dy) <= radius) {\n                    return true;\n                }\n            }\n            \n            // Check touches\n            for (const touch of this.touches.values()) {\n                const dx = touch.currentX - x;\n                const dy = touch.currentY - y;\n                if (Math.sqrt(dx * dx + dy * dy) <= radius) {\n                    return true;\n                }\n            }\n            \n            return false;\n        }\n        \n        /**\n         * Removes all event listeners and cleans up\n         */\n        destroy() {\n            // Remove canvas event listeners\n            this.canvas.removeEventListener('touchstart', this.boundHandlers.handleTouchStart);\n            this.canvas.removeEventListener('touchmove', this.boundHandlers.handleTouchMove);\n            this.canvas.removeEventListener('touchend', this.boundHandlers.handleTouchEnd);\n            this.canvas.removeEventListener('touchcancel', this.boundHandlers.handleTouchEnd);\n            this.canvas.removeEventListener('mousedown', this.boundHandlers.handleMouseDown);\n            this.canvas.removeEventListener('mousemove', this.boundHandlers.handleMouseMove);\n            this.canvas.removeEventListener('mouseup', this.boundHandlers.handleMouseUp);\n            this.canvas.removeEventListener('mouseleave', this.boundHandlers.handleMouseUp);\n            this.canvas.removeEventListener('contextmenu', this.boundHandlers.handleContextMenu);\n            \n            // Remove document event listeners\n            if (this.options.preventScroll) {\n                document.body.removeEventListener('touchmove', this.boundHandlers.preventScroll);\n            }\n            \n            // Remove window event listeners\n            window.removeEventListener('resize', this.boundHandlers.handleResize);\n            \n            // Clear handlers\n            this.clickHandlers = [];\n            this.moveHandlers = [];\n            this.resizeHandlers = [];\n            \n            // Clear state\n            this.touches.clear();\n            \n            if (this.options.debug) {\n                console.log('InputSystem: Destroyed and cleaned up');\n            }\n        }\n    }\n\n    /**\n     * Physics System\n     * \n     * Comprehensive physics engine for handling gravity, collision detection,\n     * movement calculations, boundary checking, and hit detection for the game.\n     * All physics calculations are pure functions for optimal performance.\n     * \n     * @module PhysicsSystem\n     */\n\n    /**\n     * Physics constants\n     */\n    const PHYSICS_CONSTANTS = {\n        GRAVITY: 0.15,\n        TERMINAL_VELOCITY: 12,\n        BOUNCE_DAMPING: 0.7,\n        FRICTION: 0.8,\n        MIN_VELOCITY: 0.01,\n        SWAY_AMPLITUDE: 0.5,\n        SWAY_FREQUENCY: 0.05,\n        ROTATION_DAMPING: 0.98\n    };\n\n    /**\n     * PhysicsSystem class\n     * Stateless physics engine providing pure functions for physics calculations\n     */\n    class PhysicsSystem {\n        constructor(options = {}) {\n            // Canvas dimensions for boundary checking\n            this.bounds = {\n                width: options.width || 480,\n                height: options.height || 600\n            };\n            \n            // Physics settings\n            this.gravity = options.gravity || PHYSICS_CONSTANTS.GRAVITY;\n            this.terminalVelocity = options.terminalVelocity || PHYSICS_CONSTANTS.TERMINAL_VELOCITY;\n            this.bounceDamping = options.bounceDamping || PHYSICS_CONSTANTS.BOUNCE_DAMPING;\n            this.friction = options.friction || PHYSICS_CONSTANTS.FRICTION;\n            \n            // Performance optimization flags\n            this.enableRotation = options.enableRotation !== false;\n            this.enableSway = options.enableSway !== false;\n            this.enableBounce = options.enableBounce !== false;\n        }\n        \n        /**\n         * Update canvas bounds\n         * @param {number} width - Canvas width\n         * @param {number} height - Canvas height\n         */\n        updateBounds(width, height) {\n            this.bounds.width = width;\n            this.bounds.height = height;\n        }\n        \n        /**\n         * Apply gravity to a velocity\n         * @param {number} velocityY - Current Y velocity\n         * @param {number} [gravityMultiplier=1] - Gravity multiplier\n         * @returns {number} Updated Y velocity\n         */\n        applyGravity(velocityY, gravityMultiplier = 1) {\n            const newVelocity = velocityY + (this.gravity * gravityMultiplier);\n            return Math.min(newVelocity, this.terminalVelocity);\n        }\n        \n        /**\n         * Calculate position update with velocity\n         * @param {Object} position - Current position {x, y}\n         * @param {Object} velocity - Current velocity {x, y}\n         * @param {number} [deltaTime=1] - Time delta\n         * @returns {Object} New position {x, y}\n         */\n        updatePosition(position, velocity, deltaTime = 1) {\n            return {\n                x: position.x + (velocity.x * deltaTime),\n                y: position.y + (velocity.y * deltaTime)\n            };\n        }\n        \n        /**\n         * Apply horizontal sway motion\n         * @param {number} baseX - Base X position\n         * @param {number} time - Current time/frame\n         * @param {number} swayFactor - Sway intensity factor\n         * @returns {number} X position with sway applied\n         */\n        applySway(baseX, time, swayFactor = 1) {\n            if (!this.enableSway) return baseX;\n            \n            const swayAmount = Math.sin(time * PHYSICS_CONSTANTS.SWAY_FREQUENCY + swayFactor * Math.PI) \n                              * PHYSICS_CONSTANTS.SWAY_AMPLITUDE;\n            return baseX + swayAmount;\n        }\n        \n        /**\n         * Update rotation with angular velocity\n         * @param {number} rotation - Current rotation in radians\n         * @param {number} rotationSpeed - Angular velocity\n         * @param {boolean} [applyDamping=false] - Apply rotation damping\n         * @returns {Object} Updated rotation and speed\n         */\n        updateRotation(rotation, rotationSpeed, applyDamping = false) {\n            if (!this.enableRotation) return { rotation: 0, rotationSpeed: 0 };\n            \n            const newRotation = rotation + rotationSpeed;\n            const newSpeed = applyDamping \n                ? rotationSpeed * PHYSICS_CONSTANTS.ROTATION_DAMPING \n                : rotationSpeed;\n            \n            return {\n                rotation: newRotation % (Math.PI * 2),\n                rotationSpeed: Math.abs(newSpeed) < PHYSICS_CONSTANTS.MIN_VELOCITY ? 0 : newSpeed\n            };\n        }\n        \n        /**\n         * Check if entity is within canvas bounds\n         * @param {Object} entity - Entity with x, y, width, height properties\n         * @param {Object} [customBounds] - Optional custom bounds\n         * @returns {Object} Boundary check results\n         */\n        checkBounds(entity, customBounds) {\n            const bounds = customBounds || this.bounds;\n            const width = entity.width || entity.size || 0;\n            const height = entity.height || entity.size || 0;\n            \n            const left = entity.x < 0;\n            const right = entity.x + width > bounds.width;\n            const top = entity.y < 0;\n            const bottom = entity.y + height > bounds.height;\n            const offScreenBottom = entity.y > bounds.height;\n            const offScreenTop = entity.y + height < 0;\n            \n            return {\n                inBounds: !left && !right && !top && !bottom,\n                left,\n                right,\n                top,\n                bottom,\n                offScreenBottom,\n                offScreenTop\n            };\n        }\n        \n        /**\n         * Apply boundary collision with optional bounce\n         * @param {Object} entity - Entity with position and velocity\n         * @param {Object} boundaryCheck - Result from checkBounds\n         * @returns {Object} Updated position and velocity\n         */\n        applyBoundaryCollision(entity, boundaryCheck) {\n            const result = {\n                x: entity.x,\n                y: entity.y,\n                vx: entity.vx || 0,\n                vy: entity.vy || 0,\n                bounced: false\n            };\n            \n            // Left boundary\n            if (boundaryCheck.left) {\n                result.x = 0;\n                if (this.enableBounce) {\n                    result.vx = Math.abs(result.vx) * this.bounceDamping;\n                    result.bounced = true;\n                } else {\n                    result.vx = 0;\n                }\n            }\n            \n            // Right boundary\n            if (boundaryCheck.right) {\n                result.x = this.bounds.width - entity.width;\n                if (this.enableBounce) {\n                    result.vx = -Math.abs(result.vx) * this.bounceDamping;\n                    result.bounced = true;\n                } else {\n                    result.vx = 0;\n                }\n            }\n            \n            // Bottom boundary (ground)\n            if (boundaryCheck.bottom && entity.vy > 0) {\n                result.y = this.bounds.height - entity.height;\n                if (this.enableBounce) {\n                    result.vy = -Math.abs(result.vy) * this.bounceDamping;\n                    result.vx *= this.friction;\n                    result.bounced = true;\n                    \n                    // Stop tiny bounces\n                    if (Math.abs(result.vy) < PHYSICS_CONSTANTS.MIN_VELOCITY) {\n                        result.vy = 0;\n                    }\n                } else {\n                    result.vy = 0;\n                }\n            }\n            \n            return result;\n        }\n        \n        /**\n         * Circle-circle collision detection\n         * @param {Object} circle1 - First circle {x, y, radius}\n         * @param {Object} circle2 - Second circle {x, y, radius}\n         * @returns {boolean} True if circles collide\n         */\n        checkCircleCollision(circle1, circle2) {\n            const dx = circle1.x - circle2.x;\n            const dy = circle1.y - circle2.y;\n            const distance = Math.sqrt(dx * dx + dy * dy);\n            return distance < circle1.radius + circle2.radius;\n        }\n        \n        /**\n         * Point-circle collision detection\n         * @param {number} pointX - Point X coordinate\n         * @param {number} pointY - Point Y coordinate\n         * @param {Object} circle - Circle {x, y, radius}\n         * @returns {boolean} True if point is inside circle\n         */\n        checkPointCircleCollision(pointX, pointY, circle) {\n            const dx = pointX - circle.x;\n            const dy = pointY - circle.y;\n            const distance = Math.sqrt(dx * dx + dy * dy);\n            return distance <= circle.radius;\n        }\n        \n        /**\n         * Rectangle-rectangle collision detection\n         * @param {Object} rect1 - First rectangle {x, y, width, height}\n         * @param {Object} rect2 - Second rectangle {x, y, width, height}\n         * @returns {boolean} True if rectangles collide\n         */\n        checkRectCollision(rect1, rect2) {\n            return rect1.x < rect2.x + rect2.width &&\n                   rect1.x + rect1.width > rect2.x &&\n                   rect1.y < rect2.y + rect2.height &&\n                   rect1.y + rect1.height > rect2.y;\n        }\n        \n        /**\n         * Point-rectangle collision detection\n         * @param {number} pointX - Point X coordinate\n         * @param {number} pointY - Point Y coordinate\n         * @param {Object} rect - Rectangle {x, y, width, height}\n         * @returns {boolean} True if point is inside rectangle\n         */\n        checkPointRectCollision(pointX, pointY, rect) {\n            return pointX >= rect.x && \n                   pointX <= rect.x + rect.width &&\n                   pointY >= rect.y && \n                   pointY <= rect.y + rect.height;\n        }\n        \n        /**\n         * Check if a click/tap hits an entity (with size/radius)\n         * @param {number} clickX - Click X coordinate\n         * @param {number} clickY - Click Y coordinate\n         * @param {Object} entity - Entity to check\n         * @returns {boolean} True if click hits entity\n         */\n        isClicked(clickX, clickY, entity) {\n            // Handle circular entities\n            if (entity.radius !== undefined) {\n                const centerX = entity.x + (entity.size || entity.radius * 2) / 2;\n                const centerY = entity.y + (entity.size || entity.radius * 2) / 2;\n                return this.checkPointCircleCollision(clickX, clickY, {\n                    x: centerX,\n                    y: centerY,\n                    radius: entity.radius\n                });\n            }\n            \n            // Handle rectangular entities\n            if (entity.width !== undefined && entity.height !== undefined) {\n                return this.checkPointRectCollision(clickX, clickY, entity);\n            }\n            \n            // Handle entities with size property (assumed square)\n            if (entity.size !== undefined) {\n                return this.checkPointRectCollision(clickX, clickY, {\n                    x: entity.x,\n                    y: entity.y,\n                    width: entity.size,\n                    height: entity.size\n                });\n            }\n            \n            return false;\n        }\n        \n        /**\n         * Calculate distance between two points\n         * @param {number} x1 - First point X\n         * @param {number} y1 - First point Y\n         * @param {number} x2 - Second point X\n         * @param {number} y2 - Second point Y\n         * @returns {number} Distance between points\n         */\n        distance(x1, y1, x2, y2) {\n            const dx = x2 - x1;\n            const dy = y2 - y1;\n            return Math.sqrt(dx * dx + dy * dy);\n        }\n        \n        /**\n         * Calculate angle between two points\n         * @param {number} x1 - First point X\n         * @param {number} y1 - First point Y\n         * @param {number} x2 - Second point X\n         * @param {number} y2 - Second point Y\n         * @returns {number} Angle in radians\n         */\n        angle(x1, y1, x2, y2) {\n            return Math.atan2(y2 - y1, x2 - x1);\n        }\n        \n        /**\n         * Normalize a vector\n         * @param {number} x - Vector X component\n         * @param {number} y - Vector Y component\n         * @returns {Object} Normalized vector {x, y}\n         */\n        normalize(x, y) {\n            const magnitude = Math.sqrt(x * x + y * y);\n            \n            if (magnitude === 0) {\n                return { x: 0, y: 0 };\n            }\n            \n            return {\n                x: x / magnitude,\n                y: y / magnitude\n            };\n        }\n        \n        /**\n         * Apply physics update to an entity\n         * @param {Object} entity - Entity with physics properties\n         * @param {number} deltaTime - Time delta\n         * @param {Object} [options] - Additional options\n         * @returns {Object} Updated entity physics\n         */\n        updateEntity(entity, deltaTime = 1, options = {}) {\n            const result = {\n                x: entity.x,\n                y: entity.y,\n                vx: entity.vx || 0,\n                vy: entity.vy || 0,\n                rotation: entity.rotation || 0,\n                rotationSpeed: entity.rotationSpeed || 0\n            };\n            \n            // Apply gravity if entity has gravity enabled\n            if (entity.hasGravity !== false && !options.disableGravity) {\n                result.vy = this.applyGravity(\n                    result.vy, \n                    entity.gravityMultiplier || 1\n                );\n            }\n            \n            // Update position\n            const newPosition = this.updatePosition(\n                { x: result.x, y: result.y },\n                { x: result.vx, y: result.vy },\n                deltaTime\n            );\n            result.x = newPosition.x;\n            result.y = newPosition.y;\n            \n            // Apply sway if enabled\n            if (entity.sway !== undefined && this.enableSway) {\n                result.x = this.applySway(result.x, options.time || 0, entity.sway);\n            }\n            \n            // Update rotation\n            if (this.enableRotation) {\n                const rotationUpdate = this.updateRotation(\n                    result.rotation,\n                    result.rotationSpeed,\n                    entity.rotationDamping || false\n                );\n                result.rotation = rotationUpdate.rotation;\n                result.rotationSpeed = rotationUpdate.rotationSpeed;\n            }\n            \n            // Check boundaries\n            const boundaryCheck = this.checkBounds({\n                x: result.x,\n                y: result.y,\n                width: entity.width || entity.size || 0,\n                height: entity.height || entity.size || 0\n            });\n            \n            // Apply boundary collision if needed\n            if (!boundaryCheck.inBounds && entity.bounceOnBounds) {\n                const collision = this.applyBoundaryCollision(\n                    {\n                        x: result.x,\n                        y: result.y,\n                        vx: result.vx,\n                        vy: result.vy,\n                        width: entity.width || entity.size || 0,\n                        height: entity.height || entity.size || 0\n                    },\n                    boundaryCheck\n                );\n                \n                result.x = collision.x;\n                result.y = collision.y;\n                result.vx = collision.vx;\n                result.vy = collision.vy;\n                result.bounced = collision.bounced;\n            }\n            \n            result.offScreen = boundaryCheck.offScreenBottom || boundaryCheck.offScreenTop;\n            result.boundaryCheck = boundaryCheck;\n            \n            return result;\n        }\n        \n        /**\n         * Predict future position of an entity\n         * @param {Object} entity - Entity with physics properties\n         * @param {number} steps - Number of physics steps to predict\n         * @param {number} [deltaTime=1] - Time delta per step\n         * @returns {Object} Predicted position {x, y}\n         */\n        predictPosition(entity, steps, deltaTime = 1) {\n            let x = entity.x;\n            let y = entity.y;\n            let vx = entity.vx || 0;\n            let vy = entity.vy || 0;\n            \n            for (let i = 0; i < steps; i++) {\n                // Apply gravity\n                if (entity.hasGravity !== false) {\n                    vy = this.applyGravity(vy, entity.gravityMultiplier || 1);\n                }\n                \n                // Update position\n                x += vx * deltaTime;\n                y += vy * deltaTime;\n            }\n            \n            return { x, y };\n        }\n        \n        /**\n         * Calculate intercept point for moving targets\n         * @param {Object} shooter - Shooter position {x, y}\n         * @param {Object} target - Target with position and velocity {x, y, vx, vy}\n         * @param {number} projectileSpeed - Speed of projectile\n         * @returns {Object|null} Intercept point {x, y} or null if no intercept\n         */\n        calculateIntercept(shooter, target, projectileSpeed) {\n            const dx = target.x - shooter.x;\n            const dy = target.y - shooter.y;\n            const vx = target.vx || 0;\n            const vy = target.vy || 0;\n            \n            // Quadratic equation coefficients\n            const a = vx * vx + vy * vy - projectileSpeed * projectileSpeed;\n            const b = 2 * (dx * vx + dy * vy);\n            const c = dx * dx + dy * dy;\n            \n            const discriminant = b * b - 4 * a * c;\n            \n            if (discriminant < 0) return null;\n            \n            const t1 = (-b + Math.sqrt(discriminant)) / (2 * a);\n            const t2 = (-b - Math.sqrt(discriminant)) / (2 * a);\n            \n            const t = (t1 > 0 && t2 > 0) ? Math.min(t1, t2) : Math.max(t1, t2);\n            \n            if (t < 0) return null;\n            \n            return {\n                x: target.x + vx * t,\n                y: target.y + vy * t,\n                time: t\n            };\n        }\n    }\n\n    // Export singleton instance for convenience\n    new PhysicsSystem();\n\n    /**\n     * Mathematical Utilities\n     * \n     * Common mathematical functions and utilities used throughout the game.\n     * Includes physics calculations, random number generation, and geometric functions.\n     */\n\n\n    /**\n     * Generate random number between min and max (inclusive)\n     * Alias for random.between for backward compatibility\n     * @param {number} min - Minimum value\n     * @param {number} max - Maximum value\n     * @returns {number} Random number\n     */\n    function randomRange(min, max) {\n        return Math.random() * (max - min) + min;\n    }\n\n    /**\n     * Performance optimization utilities\n     */\n    ({\n        /**\n         * Pre-calculated sine values for performance\n         */\n        sinTable: Array.from({ length: 360 }, (_, i) => Math.sin(i * Math.PI / 180)),\n        \n        /**\n         * Pre-calculated cosine values for performance\n         */\n        cosTable: Array.from({ length: 360 }, (_, i) => Math.cos(i * Math.PI / 180))});\n\n    /**\n     * Object Pool Utility\n     * \n     * Manages pools of reusable objects to reduce garbage collection pressure\n     * and improve performance, especially on mobile devices.\n     */\n\n    class ObjectPool {\n        /**\n         * Create a new object pool\n         * @param {Function} createFn - Function to create new objects\n         * @param {Function} resetFn - Function to reset objects for reuse\n         * @param {number} initialSize - Initial pool size\n         * @param {number} maxSize - Maximum pool size\n         */\n        constructor(createFn, resetFn, initialSize = 10, maxSize = 100) {\n            this.createFn = createFn;\n            this.resetFn = resetFn;\n            this.maxSize = maxSize;\n            this.pool = [];\n            this.activeCount = 0;\n            this.totalCreated = 0;\n            this.totalReused = 0;\n            \n            // Pre-populate pool\n            for (let i = 0; i < initialSize; i++) {\n                this.pool.push(this.createFn());\n                this.totalCreated++;\n            }\n        }\n        \n        /**\n         * Get an object from the pool\n         * @param {...any} args - Arguments to pass to reset function\n         * @returns {any} Pooled object\n         */\n        get(...args) {\n            let obj;\n            \n            if (this.pool.length > 0) {\n                obj = this.pool.pop();\n                this.totalReused++;\n            } else {\n                obj = this.createFn();\n                this.totalCreated++;\n            }\n            \n            // Reset object for reuse\n            if (this.resetFn) {\n                this.resetFn(obj, ...args);\n            }\n            \n            this.activeCount++;\n            return obj;\n        }\n        \n        /**\n         * Release an object back to the pool\n         * @param {any} obj - Object to release\n         */\n        release(obj) {\n            if (!obj) return;\n            \n            // Don't exceed max pool size\n            if (this.pool.length < this.maxSize) {\n                this.pool.push(obj);\n            }\n            \n            this.activeCount = Math.max(0, this.activeCount - 1);\n        }\n        \n        /**\n         * Release multiple objects at once\n         * @param {Array} objects - Array of objects to release\n         */\n        releaseAll(objects) {\n            objects.forEach(obj => this.release(obj));\n        }\n        \n        /**\n         * Clear the pool and reset statistics\n         */\n        clear() {\n            this.pool.length = 0;\n            this.activeCount = 0;\n            this.totalCreated = 0;\n            this.totalReused = 0;\n        }\n        \n        /**\n         * Get pool statistics\n         * @returns {object} Pool statistics\n         */\n        getStats() {\n            return {\n                poolSize: this.pool.length,\n                activeCount: this.activeCount,\n                totalCreated: this.totalCreated,\n                totalReused: this.totalReused,\n                reuseRatio: this.totalCreated > 0 ? (this.totalReused / this.totalCreated) : 0,\n                maxSize: this.maxSize\n            };\n        }\n        \n        /**\n         * Check if pool is healthy (not creating too many new objects)\n         * @returns {boolean} True if pool is performing well\n         */\n        isHealthy() {\n            const stats = this.getStats();\n            return stats.reuseRatio > 0.5; // At least 50% reuse rate\n        }\n        \n        /**\n         * Resize the pool\n         * @param {number} newMaxSize - New maximum size\n         */\n        resize(newMaxSize) {\n            this.maxSize = newMaxSize;\n            \n            // Trim pool if it's now too large\n            while (this.pool.length > this.maxSize) {\n                this.pool.pop();\n            }\n        }\n        \n        /**\n         * Pre-warm the pool with objects\n         * @param {number} count - Number of objects to create\n         */\n        preWarm(count) {\n            for (let i = 0; i < count && this.pool.length < this.maxSize; i++) {\n                this.pool.push(this.createFn());\n                this.totalCreated++;\n            }\n        }\n    }\n\n    /**\n     * Pool Manager for managing multiple object pools\n     */\n    class PoolManager {\n        constructor() {\n            this.pools = new Map();\n        }\n        \n        /**\n         * Create a new pool\n         * @param {string} name - Pool name\n         * @param {Function} createFn - Function to create new objects\n         * @param {Function} resetFn - Function to reset objects\n         * @param {number} initialSize - Initial pool size\n         * @param {number} maxSize - Maximum pool size\n         */\n        createPool(name, createFn, resetFn, initialSize = 10, maxSize = 100) {\n            const pool = new ObjectPool(createFn, resetFn, initialSize, maxSize);\n            this.pools.set(name, pool);\n            return pool;\n        }\n        \n        /**\n         * Get a pool by name\n         * @param {string} name - Pool name\n         * @returns {ObjectPool} The pool\n         */\n        getPool(name) {\n            return this.pools.get(name);\n        }\n        \n        /**\n         * Get an object from a named pool\n         * @param {string} poolName - Pool name\n         * @param {...any} args - Arguments for reset function\n         * @returns {any} Pooled object\n         */\n        get(poolName, ...args) {\n            const pool = this.pools.get(poolName);\n            return pool ? pool.get(...args) : null;\n        }\n        \n        /**\n         * Release an object to a named pool\n         * @param {string} poolName - Pool name\n         * @param {any} obj - Object to release\n         */\n        release(poolName, obj) {\n            const pool = this.pools.get(poolName);\n            if (pool) {\n                pool.release(obj);\n            }\n        }\n        \n        /**\n         * Get statistics for all pools\n         * @returns {object} Statistics for all pools\n         */\n        getStats() {\n            const stats = {};\n            for (const [name, pool] of this.pools) {\n                stats[name] = pool.getStats();\n            }\n            return stats;\n        }\n        \n        /**\n         * Clear all pools\n         */\n        clearAll() {\n            for (const pool of this.pools.values()) {\n                pool.clear();\n            }\n        }\n        \n        /**\n         * Check if all pools are healthy\n         * @returns {boolean} True if all pools are performing well\n         */\n        areAllPoolsHealthy() {\n            for (const pool of this.pools.values()) {\n                if (!pool.isHealthy()) {\n                    return false;\n                }\n            }\n            return true;\n        }\n        \n        /**\n         * Get total memory savings estimate\n         * @returns {object} Memory savings information\n         */\n        getMemorySavings() {\n            let totalReused = 0;\n            let totalCreated = 0;\n            \n            for (const pool of this.pools.values()) {\n                const stats = pool.getStats();\n                totalReused += stats.totalReused;\n                totalCreated += stats.totalCreated;\n            }\n            \n            return {\n                objectsReused: totalReused,\n                objectsCreated: totalCreated,\n                savings: totalCreated > 0 ? (totalReused / totalCreated) : 0\n            };\n        }\n    }\n\n    /**\n     * Performance Monitor\n     * \n     * Monitors frame rate and performance metrics to enable adaptive quality\n     * and provide insights into performance bottlenecks for mobile optimization.\n     */\n\n    class PerformanceMonitor {\n        constructor(options = {}) {\n            this.enabled = options.enabled !== false;\n            this.sampleSize = options.sampleSize || 60; // Track last 60 frames\n            this.targetFPS = options.targetFPS || 60;\n            this.lowFPSThreshold = options.lowFPSThreshold || 45;\n            this.criticalFPSThreshold = options.criticalFPSThreshold || 30;\n            \n            // Frame timing arrays\n            this.frameTimes = [];\n            this.lastFrameTime = 0;\n            this.frameCount = 0;\n            \n            // Performance statistics\n            this.stats = {\n                currentFPS: 60,\n                averageFPS: 60,\n                minFPS: 60,\n                maxFPS: 60,\n                frameTimeMS: 16.67,\n                droppedFrames: 0,\n                performanceLevel: 'high' // high, medium, low, critical\n            };\n            \n            // Performance level history for stability\n            this.performanceLevels = [];\n            this.levelChangeDelay = options.levelChangeDelay || 120; // Frames to wait before changing level\n            \n            // Quality settings per performance level\n            this.qualitySettings = {\n                high: {\n                    maxParticles: 200,\n                    enableShadows: true,\n                    enableTextures: true,\n                    enableEffects: true,\n                    particleDetail: 1.0,\n                    renderScale: 1.0\n                },\n                medium: {\n                    maxParticles: 100,\n                    enableShadows: true,\n                    enableTextures: true,\n                    enableEffects: true,\n                    particleDetail: 0.8,\n                    renderScale: 1.0\n                },\n                low: {\n                    maxParticles: 50,\n                    enableShadows: false,\n                    enableTextures: false,\n                    enableEffects: true,\n                    particleDetail: 0.6,\n                    renderScale: 0.9\n                },\n                critical: {\n                    maxParticles: 25,\n                    enableShadows: false,\n                    enableTextures: false,\n                    enableEffects: false,\n                    particleDetail: 0.4,\n                    renderScale: 0.8\n                }\n            };\n            \n            // Event callbacks\n            this.callbacks = {\n                performanceLevelChanged: [],\n                frameDropDetected: [],\n                statsUpdated: []\n            };\n            \n            // Debug mode\n            this.debugMode = options.debugMode || false;\n        }\n        \n        /**\n         * Start monitoring (call once per frame)\n         * @param {number} currentTime - Current timestamp\n         */\n        update(currentTime) {\n            if (!this.enabled) return;\n            \n            if (this.lastFrameTime === 0) {\n                this.lastFrameTime = currentTime;\n                return;\n            }\n            \n            const frameTime = currentTime - this.lastFrameTime;\n            this.lastFrameTime = currentTime;\n            this.frameCount++;\n            \n            // Add frame time to samples\n            this.frameTimes.push(frameTime);\n            if (this.frameTimes.length > this.sampleSize) {\n                this.frameTimes.shift();\n            }\n            \n            // Update statistics\n            this.updateStats();\n            \n            // Check for performance level changes\n            this.checkPerformanceLevel();\n            \n            // Emit callbacks\n            this.emit('statsUpdated', this.stats);\n        }\n        \n        /**\n         * Update performance statistics\n         */\n        updateStats() {\n            if (this.frameTimes.length === 0) return;\n            \n            const times = this.frameTimes;\n            const frameTimeMS = times[times.length - 1];\n            \n            // Calculate FPS metrics\n            const currentFPS = Math.min(1000 / frameTimeMS, this.targetFPS);\n            const averageFrameTime = times.reduce((sum, time) => sum + time, 0) / times.length;\n            const averageFPS = Math.min(1000 / averageFrameTime, this.targetFPS);\n            const minFPS = Math.min(1000 / Math.max(...times), this.targetFPS);\n            const maxFPS = Math.min(1000 / Math.min(...times), this.targetFPS);\n            \n            // Count dropped frames (frames longer than target)\n            const targetFrameTime = 1000 / this.targetFPS;\n            const droppedFrames = times.filter(time => time > targetFrameTime * 1.5).length;\n            \n            this.stats = {\n                currentFPS: Math.round(currentFPS * 10) / 10,\n                averageFPS: Math.round(averageFPS * 10) / 10,\n                minFPS: Math.round(minFPS * 10) / 10,\n                maxFPS: Math.round(maxFPS * 10) / 10,\n                frameTimeMS: Math.round(frameTimeMS * 100) / 100,\n                droppedFrames,\n                performanceLevel: this.stats.performanceLevel\n            };\n            \n            // Detect frame drops\n            if (frameTimeMS > targetFrameTime * 2) {\n                this.emit('frameDropDetected', { frameTime: frameTimeMS, targetTime: targetFrameTime });\n            }\n        }\n        \n        /**\n         * Check if performance level should change\n         */\n        checkPerformanceLevel() {\n            let newLevel = this.determinePerformanceLevel();\n            \n            // Add to history\n            this.performanceLevels.push(newLevel);\n            if (this.performanceLevels.length > this.levelChangeDelay) {\n                this.performanceLevels.shift();\n            }\n            \n            // Only change level if it's been consistent\n            if (this.performanceLevels.length >= this.levelChangeDelay) {\n                const recentLevels = this.performanceLevels.slice(-30); // Last 30 frames\n                const levelCounts = {};\n                \n                recentLevels.forEach(level => {\n                    levelCounts[level] = (levelCounts[level] || 0) + 1;\n                });\n                \n                // Find most common level\n                const dominantLevel = Object.keys(levelCounts).reduce((a, b) => \n                    levelCounts[a] > levelCounts[b] ? a : b\n                );\n                \n                if (dominantLevel !== this.stats.performanceLevel) {\n                    const oldLevel = this.stats.performanceLevel;\n                    this.stats.performanceLevel = dominantLevel;\n                    \n                    if (this.debugMode) {\n                        console.log(`Performance level changed: ${oldLevel} ‚Üí ${dominantLevel}`);\n                    }\n                    \n                    this.emit('performanceLevelChanged', {\n                        oldLevel,\n                        newLevel: dominantLevel,\n                        settings: this.getQualitySettings()\n                    });\n                }\n            }\n        }\n        \n        /**\n         * Determine appropriate performance level based on current metrics\n         * @returns {string} Performance level\n         */\n        determinePerformanceLevel() {\n            const { averageFPS, droppedFrames } = this.stats;\n            const dropRate = droppedFrames / this.sampleSize;\n            \n            if (averageFPS >= this.targetFPS * 0.9 && dropRate < 0.1) {\n                return 'high';\n            } else if (averageFPS >= this.lowFPSThreshold && dropRate < 0.2) {\n                return 'medium';\n            } else if (averageFPS >= this.criticalFPSThreshold && dropRate < 0.4) {\n                return 'low';\n            } else {\n                return 'critical';\n            }\n        }\n        \n        /**\n         * Get current quality settings\n         * @returns {object} Quality settings for current performance level\n         */\n        getQualitySettings() {\n            return { ...this.qualitySettings[this.stats.performanceLevel] };\n        }\n        \n        /**\n         * Get performance statistics\n         * @returns {object} Current performance stats\n         */\n        getStats() {\n            return { ...this.stats };\n        }\n        \n        /**\n         * Check if performance is acceptable\n         * @returns {boolean} True if performance is good\n         */\n        isPerformanceGood() {\n            return this.stats.averageFPS >= this.lowFPSThreshold && \n                   this.stats.droppedFrames / this.sampleSize < 0.2;\n        }\n        \n        /**\n         * Check if performance is critical\n         * @returns {boolean} True if performance is critically poor\n         */\n        isPerformanceCritical() {\n            return this.stats.performanceLevel === 'critical';\n        }\n        \n        /**\n         * Force a specific performance level\n         * @param {string} level - Performance level to set\n         */\n        setPerformanceLevel(level) {\n            if (this.qualitySettings[level]) {\n                const oldLevel = this.stats.performanceLevel;\n                this.stats.performanceLevel = level;\n                \n                // Clear history to prevent immediate reversion\n                this.performanceLevels = new Array(this.levelChangeDelay).fill(level);\n                \n                this.emit('performanceLevelChanged', {\n                    oldLevel,\n                    newLevel: level,\n                    settings: this.getQualitySettings(),\n                    forced: true\n                });\n            }\n        }\n        \n        /**\n         * Reset performance monitoring\n         */\n        reset() {\n            this.frameTimes = [];\n            this.lastFrameTime = 0;\n            this.frameCount = 0;\n            this.performanceLevels = [];\n            this.stats = {\n                currentFPS: 60,\n                averageFPS: 60,\n                minFPS: 60,\n                maxFPS: 60,\n                frameTimeMS: 16.67,\n                droppedFrames: 0,\n                performanceLevel: 'high'\n            };\n        }\n        \n        /**\n         * Enable/disable monitoring\n         * @param {boolean} enabled - Whether to enable monitoring\n         */\n        setEnabled(enabled) {\n            this.enabled = enabled;\n            if (!enabled) {\n                this.reset();\n            }\n        }\n        \n        /**\n         * Set debug mode\n         * @param {boolean} debug - Whether to enable debug logging\n         */\n        setDebugMode(debug) {\n            this.debugMode = debug;\n        }\n        \n        /**\n         * Add event listener\n         * @param {string} event - Event name\n         * @param {Function} callback - Callback function\n         */\n        on(event, callback) {\n            if (this.callbacks[event]) {\n                this.callbacks[event].push(callback);\n            }\n        }\n        \n        /**\n         * Remove event listener\n         * @param {string} event - Event name\n         * @param {Function} callback - Callback function to remove\n         */\n        off(event, callback) {\n            if (this.callbacks[event]) {\n                const index = this.callbacks[event].indexOf(callback);\n                if (index > -1) {\n                    this.callbacks[event].splice(index, 1);\n                }\n            }\n        }\n        \n        /**\n         * Emit event to listeners\n         * @param {string} event - Event name\n         * @param {any} data - Event data\n         */\n        emit(event, data) {\n            if (this.callbacks[event]) {\n                this.callbacks[event].forEach(callback => {\n                    try {\n                        callback(data);\n                    } catch (error) {\n                        console.error(`Error in performance monitor ${event} callback:`, error);\n                    }\n                });\n            }\n        }\n        \n        /**\n         * Get performance report\n         * @returns {object} Detailed performance report\n         */\n        getReport() {\n            return {\n                enabled: this.enabled,\n                frameCount: this.frameCount,\n                stats: this.getStats(),\n                qualitySettings: this.getQualitySettings(),\n                isHealthy: this.isPerformanceGood(),\n                isCritical: this.isPerformanceCritical(),\n                sampleSize: this.frameTimes.length,\n                targetFPS: this.targetFPS\n            };\n        }\n    }\n\n    /**\n     * Performance UI Display\n     * \n     * Creates a real-time performance monitoring overlay for debugging and optimization.\n     * Shows FPS, object pool stats, quality level, and detailed performance metrics.\n     */\n\n    class PerformanceUI {\n        constructor(options = {}) {\n            this.enabled = options.enabled || false;\n            this.position = options.position || 'top-left'; // top-left, top-right, bottom-left, bottom-right\n            this.updateInterval = options.updateInterval || 250; // ms\n            this.maxHistory = options.maxHistory || 100;\n            \n            // UI elements\n            this.container = null;\n            this.elements = {};\n            \n            // Performance data\n            this.performanceMonitor = null;\n            this.poolManager = null;\n            this.fpsHistory = [];\n            this.lastUpdate = 0;\n            \n            // Display options\n            this.showFPS = options.showFPS !== false;\n            this.showPools = options.showPools !== false;\n            this.showQuality = options.showQuality !== false;\n            this.showDetails = options.showDetails || false;\n            this.showGraph = options.showGraph || false;\n            \n            if (this.enabled) {\n                this.createUI();\n            }\n        }\n        \n        /**\n         * Initialize with performance monitor and pool manager\n         * @param {PerformanceMonitor} performanceMonitor - Performance monitoring system\n         * @param {PoolManager} poolManager - Object pool manager\n         */\n        init(performanceMonitor, poolManager) {\n            this.performanceMonitor = performanceMonitor;\n            this.poolManager = poolManager;\n        }\n        \n        /**\n         * Create the UI overlay\n         */\n        createUI() {\n            // Create container\n            this.container = document.createElement('div');\n            this.container.id = 'performance-ui';\n            this.container.style.cssText = this.getContainerStyles();\n            \n            // Create sections\n            if (this.showFPS) {\n                this.createFPSSection();\n            }\n            \n            if (this.showQuality) {\n                this.createQualitySection();\n            }\n            \n            if (this.showPools) {\n                this.createPoolsSection();\n            }\n            \n            if (this.showDetails) {\n                this.createDetailsSection();\n            }\n            \n            if (this.showGraph) {\n                this.createGraphSection();\n            }\n            \n            // Add toggle button\n            this.createToggleButton();\n            \n            document.body.appendChild(this.container);\n        }\n        \n        /**\n         * Get container CSS styles based on position\n         */\n        getContainerStyles() {\n            const baseStyles = `\n            position: fixed;\n            z-index: 10000;\n            background: rgba(0, 0, 0, 0.8);\n            color: white;\n            font-family: 'Courier New', monospace;\n            font-size: 12px;\n            padding: 10px;\n            border-radius: 5px;\n            min-width: 200px;\n            max-width: 300px;\n            backdrop-filter: blur(5px);\n        `;\n            \n            const positions = {\n                'top-left': 'top: 10px; left: 10px;',\n                'top-right': 'top: 10px; right: 10px;',\n                'bottom-left': 'bottom: 10px; left: 10px;',\n                'bottom-right': 'bottom: 10px; right: 10px;'\n            };\n            \n            return baseStyles + positions[this.position];\n        }\n        \n        /**\n         * Create FPS display section\n         */\n        createFPSSection() {\n            const section = document.createElement('div');\n            section.innerHTML = `\n            <div style=\"font-weight: bold; margin-bottom: 5px;\">üéØ Performance</div>\n            <div>FPS: <span id=\"perf-fps\">--</span></div>\n            <div>Avg: <span id=\"perf-avg-fps\">--</span></div>\n            <div>Min: <span id=\"perf-min-fps\">--</span></div>\n            <div>Frame: <span id=\"perf-frame-time\">--</span>ms</div>\n            <div>Drops: <span id=\"perf-drops\">--</span></div>\n        `;\n            \n            this.container.appendChild(section);\n            \n            // Store element references\n            this.elements.fps = document.getElementById('perf-fps');\n            this.elements.avgFps = document.getElementById('perf-avg-fps');\n            this.elements.minFps = document.getElementById('perf-min-fps');\n            this.elements.frameTime = document.getElementById('perf-frame-time');\n            this.elements.drops = document.getElementById('perf-drops');\n        }\n        \n        /**\n         * Create quality level section\n         */\n        createQualitySection() {\n            const section = document.createElement('div');\n            section.style.marginTop = '10px';\n            section.innerHTML = `\n            <div style=\"font-weight: bold; margin-bottom: 5px;\">‚öôÔ∏è Quality</div>\n            <div>Level: <span id=\"perf-quality-level\">--</span></div>\n            <div>Particles: <span id=\"perf-max-particles\">--</span></div>\n            <div>Shadows: <span id=\"perf-shadows\">--</span></div>\n            <div>Effects: <span id=\"perf-effects\">--</span></div>\n        `;\n            \n            this.container.appendChild(section);\n            \n            this.elements.qualityLevel = document.getElementById('perf-quality-level');\n            this.elements.maxParticles = document.getElementById('perf-max-particles');\n            this.elements.shadows = document.getElementById('perf-shadows');\n            this.elements.effects = document.getElementById('perf-effects');\n        }\n        \n        /**\n         * Create object pools section\n         */\n        createPoolsSection() {\n            const section = document.createElement('div');\n            section.style.marginTop = '10px';\n            section.innerHTML = `\n            <div style=\"font-weight: bold; margin-bottom: 5px;\">üé± Object Pools</div>\n            <div id=\"perf-pools-content\">\n                <!-- Pool stats will be inserted here -->\n            </div>\n        `;\n            \n            this.container.appendChild(section);\n            this.elements.poolsContent = document.getElementById('perf-pools-content');\n        }\n        \n        /**\n         * Create detailed metrics section\n         */\n        createDetailsSection() {\n            const section = document.createElement('div');\n            section.style.marginTop = '10px';\n            section.innerHTML = `\n            <div style=\"font-weight: bold; margin-bottom: 5px;\">üìä Details</div>\n            <div>Memory: <span id=\"perf-memory\">--</span></div>\n            <div>Entities: <span id=\"perf-entities\">--</span></div>\n            <div>Draw Calls: <span id=\"perf-draw-calls\">--</span></div>\n            <div>Performance: <span id=\"perf-health\">--</span></div>\n        `;\n            \n            this.container.appendChild(section);\n            \n            this.elements.memory = document.getElementById('perf-memory');\n            this.elements.entities = document.getElementById('perf-entities');\n            this.elements.drawCalls = document.getElementById('perf-draw-calls');\n            this.elements.health = document.getElementById('perf-health');\n        }\n        \n        /**\n         * Create FPS graph section\n         */\n        createGraphSection() {\n            const section = document.createElement('div');\n            section.style.marginTop = '10px';\n            section.innerHTML = `\n            <div style=\"font-weight: bold; margin-bottom: 5px;\">üìà FPS Graph</div>\n            <canvas id=\"perf-graph\" width=\"180\" height=\"50\" style=\"background: rgba(255,255,255,0.1); border-radius: 3px;\"></canvas>\n        `;\n            \n            this.container.appendChild(section);\n            this.elements.graph = document.getElementById('perf-graph');\n            this.graphCtx = this.elements.graph.getContext('2d');\n        }\n        \n        /**\n         * Create toggle button\n         */\n        createToggleButton() {\n            const button = document.createElement('button');\n            button.innerHTML = 'üëÅÔ∏è';\n            button.style.cssText = `\n            position: absolute;\n            top: -5px;\n            right: -5px;\n            width: 20px;\n            height: 20px;\n            border: none;\n            border-radius: 50%;\n            background: rgba(255, 255, 255, 0.2);\n            color: white;\n            font-size: 10px;\n            cursor: pointer;\n            display: flex;\n            align-items: center;\n            justify-content: center;\n        `;\n            \n            button.onclick = () => this.toggle();\n            this.container.appendChild(button);\n        }\n        \n        /**\n         * Update performance display\n         * @param {number} currentTime - Current timestamp\n         * @param {object} gameData - Additional game data (entities, etc.)\n         */\n        update(currentTime, gameData = {}) {\n            if (!this.enabled || !this.container || !this.performanceMonitor) return;\n            \n            // Throttle updates\n            if (currentTime - this.lastUpdate < this.updateInterval) return;\n            this.lastUpdate = currentTime;\n            \n            const stats = this.performanceMonitor.getStats();\n            const qualitySettings = this.performanceMonitor.getQualitySettings();\n            \n            // Update FPS data\n            if (this.showFPS) {\n                this.updateFPSDisplay(stats);\n            }\n            \n            // Update quality data\n            if (this.showQuality) {\n                this.updateQualityDisplay(stats, qualitySettings);\n            }\n            \n            // Update pool data\n            if (this.showPools && this.poolManager) {\n                this.updatePoolsDisplay();\n            }\n            \n            // Update detailed metrics\n            if (this.showDetails) {\n                this.updateDetailsDisplay(stats, gameData);\n            }\n            \n            // Update graph\n            if (this.showGraph) {\n                this.updateGraph(stats.currentFPS);\n            }\n        }\n        \n        /**\n         * Update FPS display elements\n         */\n        updateFPSDisplay(stats) {\n            if (this.elements.fps) {\n                this.elements.fps.textContent = stats.currentFPS.toFixed(1);\n                this.elements.fps.style.color = this.getFPSColor(stats.currentFPS);\n            }\n            \n            if (this.elements.avgFps) {\n                this.elements.avgFps.textContent = stats.averageFPS.toFixed(1);\n            }\n            \n            if (this.elements.minFps) {\n                this.elements.minFps.textContent = stats.minFPS.toFixed(1);\n            }\n            \n            if (this.elements.frameTime) {\n                this.elements.frameTime.textContent = stats.frameTimeMS.toFixed(2);\n            }\n            \n            if (this.elements.drops) {\n                this.elements.drops.textContent = stats.droppedFrames;\n                this.elements.drops.style.color = stats.droppedFrames > 5 ? '#ff6b6b' : '#51cf66';\n            }\n        }\n        \n        /**\n         * Update quality display elements\n         */\n        updateQualityDisplay(stats, qualitySettings) {\n            if (this.elements.qualityLevel) {\n                this.elements.qualityLevel.textContent = stats.performanceLevel;\n                this.elements.qualityLevel.style.color = this.getQualityColor(stats.performanceLevel);\n            }\n            \n            if (this.elements.maxParticles) {\n                this.elements.maxParticles.textContent = qualitySettings.maxParticles;\n            }\n            \n            if (this.elements.shadows) {\n                this.elements.shadows.textContent = qualitySettings.enableShadows ? '‚úÖ' : '‚ùå';\n            }\n            \n            if (this.elements.effects) {\n                this.elements.effects.textContent = qualitySettings.enableEffects ? '‚úÖ' : '‚ùå';\n            }\n        }\n        \n        /**\n         * Update pools display\n         */\n        updatePoolsDisplay() {\n            const poolStats = this.poolManager.getStats();\n            let html = '';\n            \n            for (const [name, stats] of Object.entries(poolStats)) {\n                const utilization = ((stats.activeCount / (stats.poolSize + stats.activeCount)) * 100).toFixed(0);\n                const efficiency = (stats.reuseRatio * 100).toFixed(0);\n                \n                html += `\n                <div style=\"font-size: 10px; margin: 2px 0;\">\n                    <div>${name}: ${stats.activeCount}/${stats.poolSize + stats.activeCount}</div>\n                    <div style=\"color: #888;\">Use: ${utilization}% | Reuse: ${efficiency}%</div>\n                </div>\n            `;\n            }\n            \n            if (this.elements.poolsContent) {\n                this.elements.poolsContent.innerHTML = html;\n            }\n        }\n        \n        /**\n         * Update detailed metrics\n         */\n        updateDetailsDisplay(stats, gameData) {\n            if (this.elements.memory && window.performance && window.performance.memory) {\n                const mb = (window.performance.memory.usedJSHeapSize / 1024 / 1024).toFixed(1);\n                this.elements.memory.textContent = `${mb}MB`;\n            }\n            \n            if (this.elements.entities) {\n                const entityCount = (gameData.particles || []).length + \n                                  (gameData.ingredients || []).length + \n                                  (gameData.powerUps || []).length;\n                this.elements.entities.textContent = entityCount;\n            }\n            \n            if (this.elements.drawCalls && gameData.renderer) {\n                const rendererStats = gameData.renderer.getStats();\n                this.elements.drawCalls.textContent = rendererStats.drawCalls || '--';\n            }\n            \n            if (this.elements.health) {\n                const isHealthy = this.performanceMonitor.isPerformanceGood();\n                this.elements.health.textContent = isHealthy ? '‚úÖ Good' : '‚ö†Ô∏è Poor';\n                this.elements.health.style.color = isHealthy ? '#51cf66' : '#ff6b6b';\n            }\n        }\n        \n        /**\n         * Update FPS graph\n         */\n        updateGraph(currentFPS) {\n            if (!this.graphCtx) return;\n            \n            this.fpsHistory.push(currentFPS);\n            if (this.fpsHistory.length > this.maxHistory) {\n                this.fpsHistory.shift();\n            }\n            \n            // Clear canvas\n            this.graphCtx.clearRect(0, 0, 180, 50);\n            \n            // Draw grid\n            this.graphCtx.strokeStyle = 'rgba(255, 255, 255, 0.1)';\n            this.graphCtx.lineWidth = 1;\n            for (let i = 0; i <= 50; i += 10) {\n                this.graphCtx.beginPath();\n                this.graphCtx.moveTo(0, i);\n                this.graphCtx.lineTo(180, i);\n                this.graphCtx.stroke();\n            }\n            \n            // Draw FPS line\n            if (this.fpsHistory.length > 1) {\n                this.graphCtx.strokeStyle = '#51cf66';\n                this.graphCtx.lineWidth = 2;\n                this.graphCtx.beginPath();\n                \n                for (let i = 0; i < this.fpsHistory.length; i++) {\n                    const x = (i / this.fpsHistory.length) * 180;\n                    const y = 50 - (this.fpsHistory[i] / 60) * 50; // Assume 60 FPS max\n                    \n                    if (i === 0) {\n                        this.graphCtx.moveTo(x, y);\n                    } else {\n                        this.graphCtx.lineTo(x, y);\n                    }\n                }\n                \n                this.graphCtx.stroke();\n            }\n            \n            // Draw 60 FPS reference line\n            this.graphCtx.strokeStyle = 'rgba(255, 255, 255, 0.3)';\n            this.graphCtx.lineWidth = 1;\n            this.graphCtx.setLineDash([2, 2]);\n            this.graphCtx.beginPath();\n            this.graphCtx.moveTo(0, 0);\n            this.graphCtx.lineTo(180, 0);\n            this.graphCtx.stroke();\n            this.graphCtx.setLineDash([]);\n        }\n        \n        /**\n         * Get color for FPS display\n         */\n        getFPSColor(fps) {\n            if (fps >= 55) return '#51cf66'; // Green\n            if (fps >= 45) return '#ffd43b'; // Yellow\n            if (fps >= 30) return '#ff8c42'; // Orange\n            return '#ff6b6b'; // Red\n        }\n        \n        /**\n         * Get color for quality level display\n         */\n        getQualityColor(level) {\n            const colors = {\n                'high': '#51cf66',\n                'medium': '#ffd43b',\n                'low': '#ff8c42',\n                'critical': '#ff6b6b'\n            };\n            return colors[level] || '#ffffff';\n        }\n        \n        /**\n         * Toggle UI visibility\n         */\n        toggle() {\n            if (this.container) {\n                this.enabled = !this.enabled;\n                this.container.style.display = this.enabled ? 'block' : 'none';\n            }\n        }\n        \n        /**\n         * Show the UI\n         */\n        show() {\n            this.enabled = true;\n            if (this.container) {\n                this.container.style.display = 'block';\n            } else {\n                this.createUI();\n            }\n        }\n        \n        /**\n         * Hide the UI\n         */\n        hide() {\n            this.enabled = false;\n            if (this.container) {\n                this.container.style.display = 'none';\n            }\n        }\n        \n        /**\n         * Destroy the UI\n         */\n        destroy() {\n            if (this.container) {\n                this.container.remove();\n                this.container = null;\n            }\n            this.elements = {};\n        }\n        \n        /**\n         * Set position of the UI\n         * @param {string} position - New position (top-left, top-right, bottom-left, bottom-right)\n         */\n        setPosition(position) {\n            this.position = position;\n            if (this.container) {\n                const styles = this.getContainerStyles();\n                this.container.style.cssText = styles;\n            }\n        }\n        \n        /**\n         * Configure which sections to show\n         * @param {object} options - Display options\n         */\n        configure(options) {\n            Object.assign(this, options);\n            \n            if (this.container) {\n                this.container.remove();\n                this.createUI();\n            }\n        }\n    }\n\n    /**\n     * @fileoverview Main Game class that orchestrates all game systems and entities\n     * Integrates all modular components to create the complete Burger Drop game experience\n     */\n\n\n    /**\n     * Main Game class that manages the game loop and coordinates all systems\n     */\n    class Game {\n        /**\n         * Create a new game instance\n         * @param {HTMLCanvasElement} canvas - The canvas element to render to\n         * @param {Object} options - Game configuration options\n         */\n        constructor(canvas, options = {}) {\n            this.canvas = canvas;\n            this.ctx = canvas.getContext('2d');\n            \n            // Configuration\n            this.config = {\n                initialLives: 3,\n                initialSpeed: 4,\n                spawnRate: 40,\n                maxOrders: 3,\n                powerUpSpawnInterval: 900, // 15 seconds at 60fps\n                difficultyIncreaseRate: 0.0001,\n                ...options\n            };\n            \n            // Initialize game state\n            this.state = new GameState();\n            this.state.core.lives = this.config.initialLives;\n            \n            // Initialize systems\n            this.audioSystem = new AudioSystem();\n            this.renderer = new Renderer(this.canvas);\n            this.inputSystem = new InputSystem(this.canvas);\n            this.physicsSystem = new PhysicsSystem();\n            this.performanceMonitor = new PerformanceMonitor({\n                enabled: options.enablePerformanceMonitoring !== false,\n                debugMode: options.debugPerformance || false\n            });\n            this.performanceUI = new PerformanceUI({\n                enabled: options.showPerformanceUI || false,\n                position: options.performanceUIPosition || 'top-right',\n                showFPS: true,\n                showPools: true,\n                showQuality: true,\n                showDetails: options.debugPerformance || false,\n                showGraph: options.debugPerformance || false\n            });\n            \n            // Entity arrays\n            this.ingredients = [];\n            this.orders = [];\n            this.particles = [];\n            this.powerUps = [];\n            \n            // Initialize object pools\n            this.poolManager = new PoolManager();\n            this.initializeObjectPools();\n            \n            // Game loop variables\n            this.animationId = null;\n            this.lastTime = 0;\n            this.deltaTime = 0;\n            this.frameCount = 0;\n            this.isPaused = false;\n            \n            // Spawn timers\n            this.lastSpawn = 0;\n            this.lastPowerUpSpawn = 0;\n            \n            // Order templates\n            this.orderTemplates = [\n                { name: 'Classic Burger', ingredients: ['bun_bottom', 'patty', 'cheese', 'lettuce', 'tomato', 'bun_top'], time: 30 },\n                { name: 'Simple Burger', ingredients: ['bun_bottom', 'patty', 'bun_top'], time: 20 },\n                { name: 'Cheese Burger', ingredients: ['bun_bottom', 'patty', 'cheese', 'bun_top'], time: 25 },\n                { name: 'Veggie Burger', ingredients: ['bun_bottom', 'lettuce', 'tomato', 'onion', 'pickle', 'bun_top'], time: 30 },\n                { name: 'Bacon Burger', ingredients: ['bun_bottom', 'patty', 'bacon', 'cheese', 'bun_top'], time: 35 },\n                { name: 'Breakfast Burger', ingredients: ['bun_bottom', 'patty', 'egg', 'bacon', 'cheese', 'bun_top'], time: 40 }\n            ];\n            \n            // Bind methods\n            this.update = this.update.bind(this);\n            this.render = this.render.bind(this);\n            this.gameLoop = this.gameLoop.bind(this);\n            this.handleInput = this.handleInput.bind(this);\n            \n            // Setup input handlers\n            this.setupInputHandlers();\n            \n            // Initialize renderer patterns\n            this.renderer.initializePatterns();\n            \n            // Load high score\n            this.loadHighScore();\n        }\n        \n        /**\n         * Initialize object pools for frequently created objects\n         */\n        initializeObjectPools() {\n            // Particle pool for general particles\n            this.poolManager.createPool('particle',\n                Particle.createFactory(),\n                Particle.resetParticle,\n                50, // initial size\n                200 // max size\n            );\n            \n            // Celebration particle pool (for special effects)\n            this.poolManager.createPool('celebrationParticle',\n                Particle.createFactory(),\n                Particle.resetParticle,\n                20, // initial size\n                100 // max size\n            );\n            \n            // Ingredient pool\n            this.poolManager.createPool('ingredient',\n                () => new Ingredient('bun_top', { canvasWidth: this.canvas.width, canvasHeight: this.canvas.height }),\n                (ingredient, type, options = {}) => {\n                    ingredient.init(type, {\n                        ...options,\n                        canvasWidth: this.canvas.width,\n                        canvasHeight: this.canvas.height\n                    });\n                },\n                15, // initial size\n                50  // max size\n            );\n            \n            // Setup performance monitoring callbacks\n            this.setupPerformanceCallbacks();\n            \n            // Initialize performance UI\n            this.performanceUI.init(this.performanceMonitor, this.poolManager);\n        }\n        \n        /**\n         * Setup performance monitoring callbacks\n         */\n        setupPerformanceCallbacks() {\n            // Listen for performance level changes\n            this.performanceMonitor.on('performanceLevelChanged', (data) => {\n                const { newLevel, settings } = data;\n                console.log(`Performance level changed to: ${newLevel}`);\n                \n                // Apply new quality settings\n                this.applyQualitySettings(settings);\n            });\n            \n            // Listen for frame drops\n            this.performanceMonitor.on('frameDropDetected', (data) => {\n                if (this.config.debugPerformance) {\n                    console.warn(`Frame drop detected: ${data.frameTime.toFixed(2)}ms`);\n                }\n            });\n        }\n        \n        /**\n         * Apply quality settings based on performance level\n         * @param {Object} settings - Quality settings to apply\n         */\n        applyQualitySettings(settings) {\n            // Update renderer settings\n            this.renderer.setFeature('shadows', settings.enableShadows);\n            this.renderer.setFeature('textures', settings.enableTextures);\n            this.renderer.setFeature('effects', settings.enableEffects);\n            \n            // Update particle limits\n            this.maxParticles = settings.maxParticles;\n            \n            // Update pool sizes based on performance level\n            const particlePool = this.poolManager.getPool('particle');\n            const celebrationPool = this.poolManager.getPool('celebrationParticle');\n            \n            if (particlePool) {\n                particlePool.resize(Math.floor(settings.maxParticles * 1.5));\n            }\n            if (celebrationPool) {\n                celebrationPool.resize(Math.floor(settings.maxParticles * 0.5));\n            }\n            \n            // Trim excess particles if we're over the new limit\n            if (this.particles.length > settings.maxParticles) {\n                const excessParticles = this.particles.splice(settings.maxParticles);\n                excessParticles.forEach(particle => {\n                    if (particle.type === 'celebration') {\n                        this.poolManager.release('celebrationParticle', particle);\n                    } else {\n                        this.poolManager.release('particle', particle);\n                    }\n                });\n            }\n        }\n        \n        /**\n         * Setup input event handlers\n         */\n        setupInputHandlers() {\n            this.unregisterClick = this.inputSystem.onClick((event) => this.handleInput(event));\n        }\n        \n        /**\n         * Handle input events\n         * @param {Object} event - Input event data\n         */\n        handleInput(event) {\n            if (this.state.gameState !== 'playing' || this.isPaused) return;\n            \n            const { x, y } = event;\n            \n            // Check power-up collection\n            for (let i = this.powerUps.length - 1; i >= 0; i--) {\n                const powerUp = this.powerUps[i];\n                if (powerUp.isClicked(x, y)) {\n                    this.collectPowerUp(powerUp, i);\n                    return;\n                }\n            }\n            \n            // Check ingredient collection\n            for (let i = this.ingredients.length - 1; i >= 0; i--) {\n                const ingredient = this.ingredients[i];\n                if (ingredient.isClicked(x, y)) {\n                    this.collectIngredient(ingredient, i);\n                    return;\n                }\n            }\n        }\n        \n        /**\n         * Collect a power-up\n         * @param {PowerUp} powerUp - The power-up to collect\n         * @param {number} index - Index in the power-ups array\n         */\n        collectPowerUp(powerUp, index) {\n            // Activate the power-up\n            this.state.activatePowerUp(powerUp.type);\n            \n            // Play sound\n            this.audioSystem.playPowerUpActivate(powerUp.type);\n            \n            // Visual feedback\n            this.renderer.startScreenFlash(powerUp.data.color, 0.2, 8);\n            \n            // Create celebration particles\n            const centerX = powerUp.x + powerUp.size / 2;\n            const centerY = powerUp.y + powerUp.size / 2;\n            \n            for (let i = 0; i < 3; i++) {\n                const particle = this.poolManager.get('celebrationParticle',\n                    centerX + randomRange(-50, 50),\n                    centerY + randomRange(-50, 50),\n                    powerUp.data.color,\n                    powerUp.data.emoji,\n                    {}\n                );\n                this.particles.push(particle);\n            }\n            \n            // Remove power-up\n            this.powerUps.splice(index, 1);\n        }\n        \n        /**\n         * Collect an ingredient\n         * @param {Ingredient} ingredient - The ingredient to collect\n         * @param {number} index - Index in the ingredients array\n         */\n        collectIngredient(ingredient, index) {\n            let correctOrder = null;\n            let result = 'wrong';\n            \n            // Check all orders for matching ingredient\n            for (const order of this.orders) {\n                result = order.checkIngredient(ingredient.type);\n                if (result !== 'wrong') {\n                    correctOrder = order;\n                    break;\n                }\n            }\n            \n            if (result !== 'wrong') {\n                // Correct ingredient\n                const points = this.calculatePoints(ingredient, correctOrder);\n                this.state.addScore(points);\n                \n                if (result === 'completed') {\n                    // Order completed\n                    this.completeOrder(correctOrder);\n                } else {\n                    // Correct ingredient, order continues\n                    this.state.incrementCombo();\n                    this.audioSystem.playCollect();\n                    \n                    // Create success particles\n                    for (let i = 0; i < 5; i++) {\n                        const particle = this.poolManager.get('particle',\n                            ingredient.x + ingredient.data.size / 2,\n                            ingredient.y + ingredient.data.size / 2,\n                            '#00FF00',\n                            '',\n                            'star',\n                            {}\n                        );\n                        this.particles.push(particle);\n                    }\n                }\n                \n                // Create floating score text\n                this.createFloatingText(\n                    `+${points}`,\n                    ingredient.x + ingredient.data.size / 2,\n                    ingredient.y,\n                    '#00FF00'\n                );\n            } else {\n                // Wrong ingredient\n                this.state.resetCombo();\n                this.renderer.startScreenShake(10, 15);\n                this.audioSystem.playError();\n                \n                // Create error particles\n                for (let i = 0; i < 3; i++) {\n                    const particle = this.poolManager.get('particle',\n                        ingredient.x + ingredient.data.size / 2,\n                        ingredient.y + ingredient.data.size / 2,\n                        '#FF0000',\n                        '‚úó',\n                        'default',\n                        {}\n                    );\n                    this.particles.push(particle);\n                }\n            }\n            \n            // Remove ingredient\n            ingredient.collected = true;\n            this.ingredients.splice(index, 1);\n            this.poolManager.release('ingredient', ingredient);\n        }\n        \n        /**\n         * Calculate points for collecting an ingredient\n         * @param {Ingredient} ingredient - The collected ingredient\n         * @param {Order} order - The order being filled\n         * @returns {number} Points earned\n         */\n        calculatePoints(ingredient, order) {\n            let basePoints = 10;\n            \n            // Time bonus\n            const timeBonus = Math.floor(order.timeLeft / 1000);\n            \n            // Combo multiplier\n            const comboMultiplier = this.state.combo;\n            \n            // Power-up multiplier\n            const powerUpMultiplier = this.state.activePowerUps.scoreMultiplier.active ? \n                this.state.activePowerUps.scoreMultiplier.multiplier : 1;\n            \n            return Math.floor((basePoints + timeBonus) * comboMultiplier * powerUpMultiplier);\n        }\n        \n        /**\n         * Complete an order\n         * @param {Order} order - The completed order\n         */\n        completeOrder(order) {\n            // Big combo increase\n            this.state.incrementCombo(5);\n            \n            // Bonus points\n            const bonusPoints = Math.floor(100 * this.state.combo * \n                (this.state.activePowerUps.scoreMultiplier.active ? 2 : 1));\n            this.state.addScore(bonusPoints);\n            \n            // Play success sound\n            this.audioSystem.playOrderComplete();\n            \n            // Visual celebration\n            this.renderer.startScreenFlash('#FFD700', 0.3, 10);\n            \n            // Create celebration particles\n            const orderCenterX = order.x + order.width / 2;\n            const orderCenterY = order.y + order.height / 2;\n            \n            for (let i = 0; i < 10; i++) {\n                const angle = (i / 10) * Math.PI * 2;\n                const speed = randomRange(3, 6);\n                const particle = this.poolManager.get('celebrationParticle',\n                    orderCenterX,\n                    orderCenterY,\n                    getRandomColor(),\n                    '‚≠ê',\n                    {\n                        vx: Math.cos(angle) * speed,\n                        vy: Math.sin(angle) * speed\n                    }\n                );\n                this.particles.push(particle);\n            }\n            \n            // Create floating text\n            this.createFloatingText(\n                `+${bonusPoints}`,\n                orderCenterX,\n                orderCenterY,\n                '#FFD700'\n            );\n            \n            // Remove completed order\n            const index = this.orders.indexOf(order);\n            if (index > -1) {\n                this.orders.splice(index, 1);\n            }\n        }\n        \n        /**\n         * Create floating text effect\n         * @param {string} text - Text to display\n         * @param {number} x - X position\n         * @param {number} y - Y position\n         * @param {string} color - Text color\n         */\n        createFloatingText(text, x, y, color) {\n            const floatingText = document.createElement('div');\n            floatingText.className = 'floating-text';\n            floatingText.textContent = text;\n            floatingText.style.left = `${x}px`;\n            floatingText.style.top = `${y}px`;\n            floatingText.style.color = color;\n            floatingText.style.fontSize = '24px';\n            \n            document.getElementById('ui').appendChild(floatingText);\n            \n            // Remove after animation\n            setTimeout(() => {\n                floatingText.remove();\n            }, 1000);\n        }\n        \n        /**\n         * Spawn a new ingredient\n         */\n        spawnIngredient() {\n            // Get all possible ingredients from current orders\n            const possibleTypes = new Set();\n            this.orders.forEach(order => {\n                if (order.currentIndex < order.ingredients.length) {\n                    possibleTypes.add(order.ingredients[order.currentIndex]);\n                    // Add some random ingredients for challenge\n                    const ingredientTypes = Ingredient.getAvailableTypes();\n                    const randomType = ingredientTypes[Math.floor(Math.random() * ingredientTypes.length)];\n                    possibleTypes.add(randomType);\n                }\n            });\n            \n            if (possibleTypes.size > 0) {\n                const typesArray = Array.from(possibleTypes);\n                const type = typesArray[Math.floor(Math.random() * typesArray.length)];\n                \n                // Get ingredient from pool\n                const ingredient = this.poolManager.get('ingredient', type, {\n                    canvasWidth: this.canvas.width,\n                    canvasHeight: this.canvas.height\n                });\n                \n                // Apply current speed with difficulty scaling\n                const difficultyMultiplier = 1 + (this.state.score * this.config.difficultyIncreaseRate);\n                ingredient.speed *= difficultyMultiplier;\n                ingredient.baseSpeed *= difficultyMultiplier;\n                \n                this.ingredients.push(ingredient);\n            }\n        }\n        \n        /**\n         * Spawn a new order\n         */\n        spawnOrder() {\n            if (this.orders.length < this.config.maxOrders) {\n                const template = this.orderTemplates[Math.floor(Math.random() * this.orderTemplates.length)];\n                this.orders.push(new Order(template));\n                this.audioSystem.playNewOrder();\n            }\n        }\n        \n        /**\n         * Spawn a power-up\n         */\n        spawnPowerUp() {\n            if (this.powerUps.length < 1 && this.frameCount - this.lastPowerUpSpawn > this.config.powerUpSpawnInterval) {\n                const types = Object.keys(PowerUp.getPowerUpTypes());\n                const randomType = types[Math.floor(Math.random() * types.length)];\n                this.powerUps.push(new PowerUp(randomType));\n                this.lastPowerUpSpawn = this.frameCount;\n            }\n        }\n        \n        /**\n         * Update game state\n         * @param {number} deltaTime - Time since last update in milliseconds\n         */\n        update(deltaTime) {\n            if (this.state.gameState !== 'playing' || this.isPaused) return;\n            \n            this.frameCount++;\n            \n            // Update game state\n            this.state.update(deltaTime);\n            \n            // Update color theme\n            if (this.renderer.updateColorTheme) {\n                this.renderer.updateColorTheme(this.state.combo, this.state.score, this.frameCount);\n            }\n            \n            // Spawn entities\n            if (this.frameCount - this.lastSpawn > this.config.spawnRate) {\n                this.spawnIngredient();\n                this.lastSpawn = this.frameCount;\n            }\n            \n            // Spawn orders\n            if (this.orders.length === 0 || (this.orders.length < this.config.maxOrders && Math.random() < 0.01)) {\n                this.spawnOrder();\n            }\n            \n            // Spawn power-ups\n            this.spawnPowerUp();\n            \n            // Update ingredients\n            for (let i = this.ingredients.length - 1; i >= 0; i--) {\n                const ingredient = this.ingredients[i];\n                ingredient.update(this.frameCount, this.state.activePowerUps);\n                \n                // Remove if off screen\n                if (ingredient.y > this.canvas.height + 50) {\n                    this.ingredients.splice(i, 1);\n                    this.poolManager.release('ingredient', ingredient);\n                }\n            }\n            \n            // Update orders\n            for (let i = this.orders.length - 1; i >= 0; i--) {\n                const order = this.orders[i];\n                if (!order.update(deltaTime, this.state.activePowerUps)) {\n                    // Order expired\n                    this.orders.splice(i, 1);\n                    this.state.loseLife();\n                    this.audioSystem.playOrderExpire();\n                    this.renderer.startScreenShake(20, 30);\n                    \n                    // Check game over\n                    if (this.state.lives <= 0) {\n                        this.gameOver();\n                    }\n                }\n            }\n            \n            // Update particles\n            for (let i = this.particles.length - 1; i >= 0; i--) {\n                const particle = this.particles[i];\n                particle.update(this.frameCount);\n                \n                if (particle.life <= 0) {\n                    this.particles.splice(i, 1);\n                    // Release back to appropriate pool\n                    if (particle.type === 'celebration') {\n                        this.poolManager.release('celebrationParticle', particle);\n                    } else {\n                        this.poolManager.release('particle', particle);\n                    }\n                }\n            }\n            \n            // Update power-ups\n            for (let i = this.powerUps.length - 1; i >= 0; i--) {\n                const powerUp = this.powerUps[i];\n                powerUp.update();\n                \n                // Remove if off screen\n                if (powerUp.y > this.canvas.height + 50) {\n                    this.powerUps.splice(i, 1);\n                }\n            }\n            \n            // Update systems\n            this.renderer.updateScreenEffects();\n            \n            // Update UI\n            this.updateUI();\n        }\n        \n        /**\n         * Render game state\n         */\n        render() {\n            // Clear canvas\n            this.renderer.clear(this.canvas.width, this.canvas.height);\n            \n            // Screen shake is applied via updateScreenShake\n            // (legacy applyScreenShake call removed)\n            \n            // Draw background\n            this.renderer.drawBackground(this.canvas.width, this.canvas.height);\n            \n            // Draw orders\n            this.orders.forEach((order, index) => {\n                order.draw(this.ctx, index, this.frameCount, this.renderer);\n            });\n            \n            // Draw ingredients\n            this.ingredients.forEach(ingredient => {\n                ingredient.draw(this.ctx, this.frameCount);\n            });\n            \n            // Draw power-ups\n            this.powerUps.forEach(powerUp => {\n                powerUp.draw(this.ctx, this.frameCount);\n            });\n            \n            // Draw particles\n            this.particles.forEach(particle => {\n                particle.draw(this.ctx, this.frameCount);\n            });\n            \n\n            // Draw overlay effects like flashes and ripples\n            this.renderer.drawScreenEffects();\n            \n            // Reset transform\n            this.ctx.setTransform(1, 0, 0, 1, 0, 0);\n        }\n        \n        /**\n         * Main game loop\n         * @param {number} currentTime - Current timestamp\n         */\n        gameLoop(currentTime) {\n            if (!this.lastTime) {\n                this.lastTime = currentTime;\n            }\n            \n            // Update performance monitoring\n            this.performanceMonitor.update(currentTime);\n            \n            this.deltaTime = currentTime - this.lastTime;\n            this.lastTime = currentTime;\n            this.frameCount++;\n            \n            this.update(this.deltaTime);\n            this.render();\n            \n            // Update performance UI\n            this.performanceUI.update(currentTime, {\n                particles: this.particles,\n                ingredients: this.ingredients,\n                powerUps: this.powerUps,\n                renderer: this.renderer\n            });\n            \n            this.animationId = requestAnimationFrame((time) => this.gameLoop(time));\n        }\n        \n        /**\n         * Update UI elements\n         */\n        updateUI() {\n            // Update score\n            const scoreElement = document.getElementById('score');\n            if (scoreElement) {\n                scoreElement.textContent = `Score: ${this.state.score}`;\n                if (this.state.scoreChanged) {\n                    scoreElement.classList.add('bounce');\n                    setTimeout(() => scoreElement.classList.remove('bounce'), 400);\n                    this.state.scoreChanged = false;\n                }\n            }\n            \n            // Update combo\n            const comboElement = document.getElementById('combo');\n            if (comboElement) {\n                comboElement.textContent = `Combo: x${this.state.combo}`;\n                if (this.state.comboChanged) {\n                    comboElement.classList.add('pulse');\n                    setTimeout(() => comboElement.classList.remove('pulse'), 300);\n                    this.state.comboChanged = false;\n                }\n            }\n            \n            // Update lives\n            const livesElement = document.getElementById('lives');\n            if (livesElement) {\n                livesElement.textContent = '‚ù§Ô∏è'.repeat(this.state.lives);\n                if (this.state.livesChanged) {\n                    livesElement.classList.add('shake');\n                    setTimeout(() => livesElement.classList.remove('shake'), 500);\n                    this.state.livesChanged = false;\n                }\n            }\n            \n            // Update power-up status\n            const powerUpStatus = document.getElementById('powerUpStatus');\n            if (powerUpStatus) {\n                powerUpStatus.innerHTML = '';\n                \n                for (const [type, powerUp] of Object.entries(this.state.activePowerUps)) {\n                    if (powerUp.active) {\n                        const indicator = document.createElement('div');\n                        indicator.className = `power-up-indicator ${type.toLowerCase().replace(/([A-Z])/g, '-$1').toLowerCase()}`;\n                        \n                        const powerUpData = PowerUp.getPowerUpTypes()[type];\n                        indicator.innerHTML = `\n                        <span>${powerUpData.emoji}</span>\n                        <span>${powerUpData.name}</span>\n                        <span class=\"power-up-timer\">${Math.ceil(powerUp.timeLeft / 1000)}s</span>\n                    `;\n                        \n                        powerUpStatus.appendChild(indicator);\n                    }\n                }\n            }\n        }\n        \n        /**\n         * Handle game over\n         */\n        gameOver() {\n            this.state.gameState = 'gameOver';\n            this.audioSystem.playGameOver();\n            \n            // Update high score\n            if (this.state.score > this.state.highScore) {\n                this.state.highScore = this.state.score;\n                this.saveHighScore();\n            }\n            \n            // Show game over screen\n            const gameOverElement = document.getElementById('gameOver');\n            if (gameOverElement) {\n                gameOverElement.style.display = 'block';\n                document.getElementById('finalScore').textContent = `Final Score: ${this.state.score}`;\n                document.getElementById('highScore').textContent = `High Score: ${this.state.highScore}`;\n            }\n        }\n        \n        /**\n         * Load high score from localStorage\n         */\n        loadHighScore() {\n            try {\n                const savedScore = localStorage.getItem('burgerDropHighScore');\n                if (savedScore) {\n                    this.state.highScore = parseInt(savedScore) || 0;\n                }\n            } catch (e) {\n                console.warn('Could not load high score:', e);\n            }\n        }\n        \n        /**\n         * Save high score to localStorage\n         */\n        saveHighScore() {\n            try {\n                localStorage.setItem('burgerDropHighScore', this.state.highScore.toString());\n            } catch (e) {\n                console.warn('Could not save high score:', e);\n            }\n        }\n        \n        /**\n         * Start the game\n         */\n        start() {\n            // Hide start screen\n            const startScreen = document.getElementById('startScreen');\n            if (startScreen) {\n                startScreen.style.display = 'none';\n            }\n            \n            // Reset game state\n            this.state.startGame();\n            \n            // Release all entities back to pools\n            this.particles.forEach(particle => {\n                if (particle.type === 'celebration') {\n                    this.poolManager.release('celebrationParticle', particle);\n                } else {\n                    this.poolManager.release('particle', particle);\n                }\n            });\n            this.ingredients.forEach(ingredient => {\n                this.poolManager.release('ingredient', ingredient);\n            });\n            \n            // Clear arrays\n            this.ingredients = [];\n            this.orders = [];\n            this.particles = [];\n            this.powerUps = [];\n            this.frameCount = 0;\n            this.lastSpawn = 0;\n            this.lastPowerUpSpawn = 0;\n            \n            // Start background music\n            this.audioSystem.startBackgroundMusic();\n            \n            // Set game state\n            this.state.gameState = 'playing';\n            \n            // Start game loop\n            this.lastTime = 0;\n            this.gameLoop(0);\n        }\n        \n        /**\n         * Stop the game\n         */\n        stop() {\n            if (this.animationId) {\n                cancelAnimationFrame(this.animationId);\n                this.animationId = null;\n            }\n            \n            this.audioSystem.stopBackgroundMusic();\n            this.state.gameState = 'stopped';\n        }\n        \n        /**\n         * Toggle performance UI display\n         */\n        togglePerformanceUI() {\n            this.performanceUI.toggle();\n        }\n        \n        /**\n         * Show performance UI\n         */\n        showPerformanceUI() {\n            this.performanceUI.show();\n        }\n        \n        /**\n         * Hide performance UI\n         */\n        hidePerformanceUI() {\n            this.performanceUI.hide();\n        }\n        \n        /**\n         * Pause/unpause the game\n         */\n        pause() {\n            this.isPaused = !this.isPaused;\n            \n            if (this.isPaused) {\n                this.audioSystem.pauseBackgroundMusic();\n            } else {\n                this.audioSystem.resumeBackgroundMusic();\n            }\n        }\n        \n        /**\n         * Handle window resize\n         */\n        resize() {\n            // Canvas will be resized externally\n            // Update canvas dimensions in pools\n            const ingredientPool = this.poolManager.getPool('ingredient');\n            if (ingredientPool) {\n                ingredientPool.config.canvasWidth = this.canvas.width;\n                ingredientPool.config.canvasHeight = this.canvas.height;\n            }\n        }\n        \n        /**\n         * Get object pool statistics for debugging\n         * @returns {Object} Pool statistics\n         */\n        getPoolStats() {\n            return this.poolManager.getAllStats();\n        }\n        \n        /**\n         * Log pool statistics to console\n         */\n        logPoolStats() {\n            const stats = this.getPoolStats();\n            console.log('Object Pool Statistics:');\n            Object.entries(stats).forEach(([poolName, poolStats]) => {\n                console.log(`  ${poolName}:`, poolStats);\n            });\n        }\n        \n        /**\n         * Clean up resources\n         */\n        destroy() {\n            this.stop();\n            this.inputSystem.destroy();\n            this.audioSystem.destroy();\n            \n            // Remove event listeners\n            if (this.unregisterClick) {\n                this.unregisterClick();\n            }\n            \n            // Release all pooled objects\n            this.particles.forEach(particle => {\n                if (particle.type === 'celebration') {\n                    this.poolManager.release('celebrationParticle', particle);\n                } else {\n                    this.poolManager.release('particle', particle);\n                }\n            });\n            this.ingredients.forEach(ingredient => {\n                this.poolManager.release('ingredient', ingredient);\n            });\n            \n            // Clear references\n            this.ingredients = [];\n            this.orders = [];\n            this.particles = [];\n            this.powerUps = [];\n            \n            // Clear all pools\n            this.poolManager.clearAll();\n            \n            // Cleanup performance UI\n            this.performanceUI.destroy();\n        }\n    }\n\n    // Export for use in worker.js\n    if (typeof module !== 'undefined' && module.exports) {\n        module.exports = Game;\n    }\n\n    return Game;\n\n})();\n";

// Cloudflare Worker - Final bundled version

// Export fetch handler for module worker syntax
var workerFinal = {
  async fetch(request) {
    return handleRequest(request)
  }
};

async function handleRequest(request) {
  const url = new URL(request.url);
  
  // Serve the game HTML file for all requests
  if (url.pathname === '/' || url.pathname === '/index.html') {
    // Build the HTML with CSS injected
    let html = htmlTemplate.replace('{{CSS_CONTENT}}', cssContent);
    
    // Inject the game bundle before the inline initialization script
    const gameScript = `<script>${gameBundle}</script>`;
    html = html.replace('<script>', `${gameScript}<script>`);

    return new Response(html, {
      headers: {
        'content-type': 'text/html;charset=UTF-8',
        'Cache-Control': 'public, max-age=3600'
      }
    })
  }

  // Return 404 for other paths
  return new Response('Not Found', { status: 404 })
}

export { workerFinal as default };
//# sourceMappingURL=worker.js.map
